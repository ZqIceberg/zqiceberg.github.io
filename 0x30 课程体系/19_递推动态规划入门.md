#### 3870 - 最长递增子序列

#### 3880 - 最长公共子序列

#### 3890 - 数塔问题

#### 3910 - 最大子矩阵
问题转化为求最大子段和
	枚举两行i, j， 把ij之间的数字，求和压缩成一个数，那么就转化成了一行数字中，哪个子段和最大
	枚举i，枚举j，枚举k，O(n^3)

	若利用二维前缀和
	需要O(n^4)，枚举左上角，右下角两个点

	求最大子段和
	f[i]状态，表示以i结尾的最大子段和，f[i] = f[i-1]+a[i] 或者f[i] = a[i]

#### E. 对局匹配
先sort一遍预处理
状态表示f[i]，在序列前i个人中，选取3个人，满足两两分数差不超过k的所有选法
属性，求max
状态计算，不选i这个人，选i这个人
f[i - 1]
满足a[i] - a[i-2]<=k的条件下，可以选这个人，如果选这个人就会多一种选法，f[i-3]+1

for一遍，从i=3开始循环

#### 3920 - 回文字符串
原字符串，翻转后的字符串
求两个字符串的最长公共子序列

#### 3900 - 括号匹配
1.记忆化搜索
dfs(1, n)
判断左端点，右端点是否匹配
如果匹配，就可以往里缩小范围
否则在区间里，枚举k，切分成两个区间往下搜索

2.递推
	for (int len = 2; len <= n; len++)
		for (int i = 1; i + len - 1 <= n; i++)
					int j = i + len - 1;
外层循环枚举长度，内层循环枚举左端点，j是右端点
剩下的搜索的方式一样，左右两端点匹配，往里缩小范围
否则枚举k，切分成两个区间

这道题的实现过程，和“石子合并”很相似
