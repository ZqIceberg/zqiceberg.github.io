#### 3670 - 食堂排队
之前用单链表模拟，头插法，尾插法，都是自研出来的
头插尾插的原因是，当时不知道该如果处理，初始化的时候如何每个班级里的人是正序排队的
后面操作的时候却插入队头

现在明白了
把读入先存起来，初始化stack的时候，倒序来一遍push进栈，就完成正序了

queue<int>维护那个班级站在前面
cnt[N] 这个班级队列中有多少人
stack<int> stk[N] 维护每个班级的小队伍
queue中的班级编号和stk[] cnt[]都有一个映射的关系逻辑在这

#### 3640 - 括号匹配
用一个栈维护左括号的位置，发现一个左括号，把左括号的位置入栈
发现一个右括号，就把栈顶的左括号的位置和右括号的位置输出

#### 3660 - 栈
用三个stack<int>，来模拟操作序列，栈，答案
n <= 10，用暴力做法，递归，那么操作序列要能够递归回溯，所以需要用栈结构，pop()，再push()回来

dfs里面包含
if (!from.empty())
	{
		//取出from栈顶元素,放到to里面

if (!to.empty())
	{
		int t = to.top();
		to.pop();
		ans.push(t);

#### 3650 - 最长合法子串
stack<int> stk;
char s[N];
int f[N];
//f[]记录以这个点为终点的最长合法子串长度，仅对右括号记录
//一个合法的子串，还要判断这个子串的前一位是不是右括号，如果是，这个合法子串的长度，要加上前一个合法子串的长度，更新f[i]
//要stack记录左括号的位置，读到右括号的时候，用相对位置计算合法子串长度
//再用stack用左括号的位置，去看子串前一个位置是不是右括号，是就更新f[i]

