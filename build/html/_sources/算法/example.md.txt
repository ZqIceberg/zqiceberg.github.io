# 搜索与回溯
=============

### 概念

搜索，也就是对状态空间进行枚举，通过穷尽所有的可能来找到最优解，或者统计合法解的个数。

描述1: dfs(deep first search)， 按照深度优先的顺序对“问题状态空间”进行搜索的算法。“深搜”，是一种包括遍历形式、状态记录与检索、剪枝优化等算法整体设计的统称。提前学习建图方法后，掌握在图上进行遍历，进一步把“问题空间”类比为一张图。研究dfs算法之前，要定义该过程产生的“搜索树”结构，整个深搜算法就是基于该搜索树完成的。（用递归实现的指数型枚举、排列性枚举、组合型枚举，其实就是深搜的三种最简单的形式）

描述2: dfs，常常指利用递归函数实现暴力枚举的算法。**递归搜索**，该类搜索算法的特点在于，将要搜索的目标分成若干“层”，每层基于前几层的状态进行决策，直到达到目标状态。

>  例题：将正整数 分解成小于等于 个正整数之和，且排在后面的数必须大于等于前面的数，并输出所有方案

我们将问题分层，第 i 层决定 ai。则为了进行第 i 层决策，我们需要记录三个状态变量： n - (a1...ai)，表示后面所有正整数的和；以及 $a_{i-1}$ ，表示前一层的正整数，以确保正整数递增；以及 i ，确保我们最多输出 m 个正整数。

```cpp
void dfs(int n, int i, int a) {
  if (n == 0) {
	//输出方案
  }
    
  if (i <= m) {
    for (int j = a; j <= n; ++j) {
      arr[i] = j;
      dfs(n - j, i + 1, j);  // 请仔细思考该行含义。
    }
  }
}

dfs(n, 1, 1);
```



回溯法是一种经常被用在深度深度优先搜索（DFS）和广度优先搜索（BFS）的技巧。其本质是：走不通就回头。

> 恢复现场



**深搜模板**

``代码部分``

```
int ans = 最坏情况, now;  // now为当前答案
void dfs(传入数值) {
  if (到达目的地) ans = 从当前解与已有解中选最优;
  for (遍历所有可能性)
    if (可行) {
      进行操作;
      dfs(缩小规模);
      撤回操作;
    }
}

asd
````````````

