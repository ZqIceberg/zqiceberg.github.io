# complete search and backtracking 搜索与回溯
### 概念

搜索，也就是对状态空间进行枚举，通过穷尽所有的可能来找到最优解，或者统计合法解的个数。

**Complete search**，我们在学习递归的时候，就了解到了。递归枚举子集，递归枚举组合，递归枚举排列，是三个入门的问题。

**deep first search(dfs)**， 按照深度优先的顺序对“问题状态空间”进行搜索的算法。“深搜”，是一种包括遍历形式、状态记录与检索、剪枝优化等算法整体设计的统称。提前学习建图方法后，掌握在图上进行遍历，进一步把“问题空间”类比为一张图。研究dfs算法之前，要定义该过程产生的“搜索树”结构，整个深搜算法就是基于该搜索树完成的。（用递归实现的指数型枚举、排列性枚举、组合型枚举，其实就是深搜的三种最简单的形式）

**dfs**，常常指利用递归函数实现暴力枚举的算法。**递归搜索**，该类搜索算法的特点在于，将要搜索的目标分成若干“层”，每层基于前几层的状态进行决策，直到达到目标状态。



### 将正整数拆分问题

**问题1**：将正整数 n 分解成3个不同的正整数，如 6 = 1 + 2 + 3，排在后面的数必须大于等于前面的数，输出所有方案。

**问题2**：将正整数 n 分解成小于等于 m 个正整数之和，且排在后面的数必须大于等于前面的数，并输出所有方案。

对于**问题1**，我们可以使用循环处理，using 3 loops

```cpp
for (int i = 1; i <= n; ++i)
  for (int j = i; j <= n; ++j)
    for (int k = j; k <= n; ++k)
      if (i + j + k == n) printf("%d=%d+%d+%d\n", n, i, j, k);
```

如果问题变成“将正整数n分解成4个不同的正整数”，此时就需要4重循环。如果问题变成“分解成小于等于m个整数”，那么，就没办法使用loops去弄了，需要使用递归搜索。下面，我们考虑**问题2**。（用搜索树，来表示）

我们将问题分层，第 i 层决定 ai。则为了进行第 i 层决策，我们需要记录三个状态变量： 

* n - sum of (a1...ai)，表示后面所有正整数的和；

* $a_{i-1}$ ，表示前一层的正整数，以确保正整数递增；

* i ，确保我们最多输出 m 个正整数。

```cpp
//arr[]记录方案
void dfs(int n, int i, int a) {
  if (n == 0) {
	//输出方案
  }
    
  if (i <= m) {
    for (int j = a; j <= n; ++j) {
      arr[i] = j;
      dfs(n - j, i + 1, j);  //剩余n-j, 分解了i+1个数，前一个数用的是j
    }
  }
}

dfs(n, 1, 1);
```



### backtracking回溯

回溯法是一种经常被用在深度深度优先搜索（DFS）和广度优先搜索（BFS）的技巧。其本质是：走不通就回头。关键词：**恢复现场**。

常见例题，八皇后问题（用搜索树，来表示）

```cpp
void search(int y) {
    if (y == n) {
		count++;
		return; 
    }
    
    for (int x = 0; x < n; x++) {
       if (column[x] || diag1[x+y] || diag2[x-y+n-1]) continue;
       column[x] = diag1[x+y] = diag2[x-y+n-1] = 1;
       search(y+1);
       column[x] = diag1[x+y] = diag2[x-y+n-1] = 0;
	} 
}

search(0); //调用
```

Let *q*(*n*) denote the number of ways to place *n* queens on an *n* × *n* chessboard. The above backtracking algorithm tells us that, for example, ***q*(8) = 92**



### 深搜代码框架

```cpp
int ans = 最坏情况, now;  // now为当前答案
void dfs(传入数值) {
  if (到达目的地) ans = 从当前解与已有解中选最优;
  for (遍历所有可能性)
    if (可行) {
      进行操作;
      dfs(缩小规模);
      撤回操作;
    }
}
```



### memoization记忆化(进一步的)

记忆化搜索，是在学习动态规划的时候，用到的。用记忆化搜索的方式，实现dp。在这个章节，练习题目时，也请感受一下记忆化操作。

**记忆化模板**

```cpp
int g[MAXN];  // 定义记忆化数组
int ans = 最坏情况, now;
void dfs f(传入数值) {
  if (g[规模] != 无效数值) return;  // 或记录解，视情况而定
  if (到达目的地) ans = 从当前解与已有解中选最优;  // 输出解，视情况而定
  for (遍历所有可能性)
    if (可行) {
      进行操作;
      dfs(缩小规模);
      撤回操作;
    }
}
int main() {
  ... memset(g, 无效数值, sizeof(g));  // 初始化记忆化数组
  ...
}
```

**加记忆化的例子**，[【Luogu P5017】Noip2018-T3 摆渡车题解](https://blog.csdn.net/BWzhuzehao/article/details/108141420)

> 接下来加记忆化。其实在写记忆化搜索的时候，我个人认为加记忆化是最简单的，**只要爆搜写好并且写对，加记忆化易如反掌。哪里有 return ，哪里加记忆化**。最后代码如下（由于其余部分相同，这里只给出 dfs 代码）

**加记忆化的例子**，[聊聊动态规划与记忆化搜索](https://www.luogu.com.cn/blog/interestingLSY/memdfs-and-dp)【特别经典】

> - 不依赖任何 **外部变量**
> - 答案以返回值的形式存在, 而不能以参数的形式存在(就是不能将 dfs 定义成 dfs(pos ,tleft , nowans )*d**f**s*(*p**o**s*,*t**l**e**f**t*,*n**o**w**a**n**s*), 这里面的 nowans 不符合要求).
> - 对于相同一组参数, dfs 返回值总是相同的

> 1. 写出这道题的暴搜程序(最好是dfs)
> 2. 将这个dfs改成"无需外部变量"的dfs
> 3. 添加记忆化数组



### 《一本通》题目

##### [【例5.2】组合的输出](http://ybt.ssoier.cn:8088/problem_show.php?pid=1317)

递归实现组合枚举

##### [【例5.3】自然数的拆分](http://ybt.ssoier.cn:8088/problem_show.php?pid=1318)

拆分成若干个小于n的自然数之和

##### [LETTERS](http://ybt.ssoier.cn:8088/problem_show.php?pid=1212)

棋盘上dfs

##### [八皇后问题](http://ybt.ssoier.cn:8088/problem_show.php?pid=1213)

92种方案

##### [八皇后](http://ybt.ssoier.cn:8088/problem_show.php?pid=1214)

输出第x种方案

##### [迷宫](http://ybt.ssoier.cn:8088/problem_show.php?pid=1215)

棋盘上dfs，判断是否可达。注意是不用回溯

##### [红与黑](http://ybt.ssoier.cn:8088/problem_show.php?pid=1216)

总共能到达多少块黑色瓷砖

##### [棋盘问题](http://ybt.ssoier.cn:8088/problem_show.php?pid=1217)

棋盘形状是不规则的，只能在 # 位置上摆放。两个棋子不能同行同列，摆放k个棋子，有多少种方案。设计一个带参数的dfs函数

```cpp
void dfs(int u, int num) 枚举到第u行，已经摆放了num个棋子
    
for (int i = u; i < n; i++)
    for (int j = 0; j < n; j++){
    	if (!col[j] && g[i][j] == '#'){
        	col[j] = true;
            dfs(i + 1, num + 1);
            col[j] = false;
        }
    }
```

##### [取石子游戏](http://ybt.ssoier.cn:8088/problem_show.php?pid=1218)

从较多的那堆里取，去较少那堆的整数倍，最后把一堆棋子取空，就是赢家。多组数据，问先手是不是赢家。

a / b >= 2, 先手必胜。

a / b < 2, 先手只有一种取法。

>  不知道为啥 a / b >= 2，先手必胜。不会证明

##### [马走日](http://ybt.ssoier.cn:8088/problem_show.php?pid=1219)

给出起始位置，问有多少方案可以遍历到棋盘上的所有点。

```cpp
void dfs(int x, int y, int num) //num是已经遍历点的个数
```

用数组控制8个方向的写法，判断点合法性的方法

##### [单词接龙](http://ybt.ssoier.cn:8088/problem_show.php?pid=1220)【难】

要拼成的单词长度尽可能的长，两个单词重合的部分就会尽可能的少。

```cpp
if (a.substr(a.size() - k, k) == b.substr(0, k))
用g[i][j] = k 维护两个单词之间重叠关系
    
void dfs(string dragon, int last){
	//...
	vis[last]++;

	for (int i = 0; i < n; i++)
		if (g[last][i] && vis[i] < 2)
			dfs(dragon + s[i].substr(g[last][i]), i); 

	vis[last]--;
    //...
}

//调用
dfs(s[i], i);
```

##### [分成互质组](http://ybt.ssoier.cn:8088/problem_show.php?pid=1221)【难】

方法一：拿着鸡蛋去往篮子里放，有合适的放或者不放，没有合适的就先开一个篮子

//爆搜，每一个位置有两种操作
//对已有的每一个组进行枚举，看能不能放进去
//新建一个组，放进去

方法二：鸡蛋一排摆在地上，拿着篮子去挑鸡蛋(没看懂的)

```cpp
void dfs(int g, int gc, int tc, int start) //group count    total count
{
	if (g >= res) return ;
	if (tc == n) res = min(res, g);

	bool flag = true;
	for (int i = start; i < n; i++)
		if (!st[i] && check(group[g], gc, i)){  //传进去的是一个一维数组
			st[i] = true;
			group[g][gc] = i;
			dfs(g, gc + 1, tc + 1, i + 1);
			st[i] = false;

			flag = false;
		}

	if (flag) dfs(g + 1, 0, tc, 0);  //从0号下标开始搜
}

//调用
dfs(1, 0, 0, 0);
```

##### [放苹果](http://ybt.ssoier.cn:8088/problem_show.php?pid=1222)

苹果数量大于盘子数量，第n个盘子不放dfs(m, n - 1)，每个盘子都放一个dfs(m - n, n)

苹果数量小于盘子数量，问题等价于dfs(m, m)

问题边界：0个苹果，1种放法。1个盘子，1种放法。