# complete search and backtracking 搜索与回溯
### 概念

**搜索**，也就是对状态空间进行枚举，通过穷尽所有的可能来找到最优解，或者统计合法解的个数。

**Complete search**，我们在学习递归的时候，就了解到了。递归枚举子集，递归枚举组合，递归枚举排列，是三个入门的问题。

在讲到搜索的时候，会有几个概念，<深度优先搜索、深度优先遍历>，<宽度优先搜索、宽度优先遍历>（也叫广度优先搜索）。遍历呢，一般是指图上的搜索。我们在学习搜索的时候，主要是指学习深度优先搜索。

下面这段话，用来理解和区分这几个常用的概念问题。**depth first search(dfs)**， 按照深度优先的顺序对“问题状态空间”进行搜索的算法（理解理解搜索树，是不是深度优先?）。“深搜”，是一种包括遍历形式、状态记录与检索、剪枝优化等算法整体设计的统称。提前学习建图方法后，掌握在图上进行遍历，进一步把“问题空间”类比为一张图。研究dfs算法之前，要定义该过程产生的 “搜索树” 结构，整个深搜算法就是基于该搜索树完成的*（用递归实现的指数型枚举、排列性枚举、组合型枚举，其实就是深搜的三种最简单的形式）*。**dfs**，常常指利用递归函数实现暴力枚举的算法。**递归搜索**，该类搜索算法的特点在于，将要搜索的目标分成若干“层”，每层基于前几层的状态进行决策，直到达到目标状态。*（不要过多纠结于名词概念，能够inplementation才是王道。）*



### Complete search

**Complete search** is a general method that can be used to solve almost any algorithm problem. The idea is to generate all possible solutions to the problem using brute force, and then select the best solution or count the number of solutions, depending on the problem.

Complete search is a good technique if there is enough time to go through all the solutions, because the search is usually easy to implement and it always gives the correct answer. If complete search is too slow, other techniques, such as greedy algorithms or dynamic programming, may be needed.



##### Generating subsets生成子集问题

这个问题我们在学习递归的时候已经学习，复习一下。

##### [递归实现指数型枚举](https://www.acwing.com/problem/content/94/)

```cpp
//子集枚举
```

##### [递归实现组合型枚举](https://www.acwing.com/problem/content/95/)

```cpp
//在子集枚举的基础上，进行剪枝
```

##### Generating permutations生成排列问题

这个问题我们在学习递归的时候已经学习，复习一下。

##### [递归实现排列型枚举](https://www.acwing.com/problem/content/96/)

```cpp
//排列枚举
```



### 将正整数拆分问题

```cpp
//问题1：
  将正整数 n 分解成3个正整数，如 6 = 1 + 2 + 3，
  排在后面的数必须大于等于前面的数，输出所有方案。
 
  -- 循环实现
  -- 递归实现
      
//问题2：
  将正整数 n 分解成 小于等于m 个正整数之和，
  且排在后面的数必须 大于等于 前面的数，并输出所有方案。

      
输入：
4 3
输出： 
1 1 2 
1 3 
2 2 
4
```



对于**问题1**，我们可以使用循环处理，using 3 loops

```cpp
for (int i = 1; i <= n; ++i)
  for (int j = i; j <= n; ++j)
    for (int k = j; k <= n; ++k)
      if (i + j + k == n) printf("%d=%d+%d+%d\n", n, i, j, k);
```



如果问题变成“将正整数n分解成4个正整数”，此时就需要4重循环。如果问题变成“分解成小于等于m个整数”，那么，就没办法使用loops去弄了，需要使用递归搜索。

下面，我们考虑**问题2**。（用搜索树，来表示）

我们将问题分层，第 i 层决定 ai。则为了进行第 i 层决策，我们需要记录三个状态变量： 

* `n - sum of (a1...ai)`，表示后面所有正整数的和；

* `a_(i-1)` ，表示前一层的正整数，以确保正整数递增；Latex: ($a_{i-1}$)

* `i` ，确保我们最多输出 m 个正整数。

```cpp
//arr[]记录方案
void dfs(int n, int i, int a) {
  if (n == 0) {
	//输出方案
  }
    
  if (i <= m) {
    for (int j = a; j <= n; j++) {
      arr[i] = j;
      dfs(n - j, i + 1, j);  //剩余n-j, 分解了i+1个数，前一个数用的是j
    }
  }
}

dfs(n, 1, 1);
```

> 请上机操作，把问题1，用递归实现。



### backtracking回溯

回溯法是一种经常被用在深度深度优先搜索（DFS）和广度优先搜索（BFS）的技巧。其本质是：走不通就回头。关键词：**恢复现场**。

常见例题，八皇后问题（用搜索树，来表示）

As an example, consider the problem of calculating the number of ways *n* queens can be placed on an *n* × *n* chessboard so that no two queens attack each other. For example, when *n* = 4, there are two possible solutions:

<center>

![](../media/image-20210125154752427.png)

</center>



The problem can be solved using backtracking by placing queens to the board row by row. More precisely, exactly one queen will be placed on each row so that no queen attacks any of the queens placed before. A solution has been found when all *n* queens have been placed on the board.

For example, when *n* = 4, some partial solutions generated by the backtracking algorithm are as follows:



<center>

![](../media/image-20210125154859481.png)

</center>

At the bottom level, the three first configurations are illegal, because the queens attack each other. However, the fourth configuration is valid and it can be extended to a complete solution by placing two more queens to the board. There is only one way to place the two remaining queens.

```cpp
void search(int y) {
    if (y == n) {
		count++;
		return; 
    }
    
    for (int x = 0; x < n; x++) {
		if (column[x] || diag1[x+y] || diag2[x-y+n-1]) continue;
        column[x] = diag1[x+y] = diag2[x-y+n-1] = 1;
        search(y+1);
        column[x] = diag1[x+y] = diag2[x-y+n-1] = 0;
    }
}

search(0); //调用
```

Let *q*(*n*) denote the number of ways to place *n* queens on an *n* × *n* chessboard. The above backtracking algorithm tells us that, for example, ***q*(8) = 92**。（记忆：八皇后问题有92种方案）



```cpp
//按行枚举
//对角线 dg[u+i]，反对角线udg[n−u+i]中的下标
//u+i和 n−u+i 表示的是截距

//（1）反对角线 y=x+b, 截距 b=y−x，因为我们要把 b 当做数组下标，所以 b 不能是负的
//所以我们 +n，保证是结果是正的
//（2）而对角线 y=−x+b, 截距是 b=y+x，这里截距一定是正的，所以不需要加偏移量
#include <iostream>
using namespace std;
const int N = 20;

// bool数组用来判断搜索的下一个位置是否可行
// col列，dg对角线，udg反对角线
// g[N][N]用来存路径

int n;
char g[N][N];
bool col[N], dg[N], udg[N];

void dfs(int u)
{
    // u == n 表示已经搜了n行，故输出这条路径
    if (u == n)
    {
        for (int i = 0; i < n; i ++ ) puts(g[i]);   // 等价于cout << g[i] << endl;
        puts("");  // 换行
        return;
    }

    //对n个位置按行搜索
    for (int i = 0; i < n; i ++ )
        //剪枝(对于不满足要求的点，不再继续往下搜索)
        //udg[n - u + i]，+n是为了保证大于0
        if (!col[i] && !dg[u + i] && !udg[n - u + i])
        {
            g[u][i] = 'Q';
            col[i] = dg[u + i] = udg[n - u + i] = true;
            dfs(u + 1);
            // 恢复现场 这步很关键
            col[i] = dg[u + i] = udg[n - u + i] = false;
            g[u][i] = '.';
        }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            g[i][j] = '.';

    dfs(0);

    return 0;
}   
```



```cpp
//按每个元素进行枚举
#include <iostream>
using namespace std;
const int N = 20;

// 因为是一个个搜索，所以加了row
int n;
char g[N][N];
bool row[N], col[N], dg[N], udg[N];

// s表示已经放上去的皇后个数
void dfs(int x, int y, int s)
{
    // 处理超出边界的情况
    if (y == n) y = 0, x ++ ;

    // 说明已经放好了n个皇后，表示枚举完 n^2 个了
    if (x == n)
    {
        if (s == n)
        {
            for (int i = 0; i < n; i ++ ) puts(g[i]);
            puts("");
        }
        return;
    }

    // 不放皇后  就往下搜下一个位置
    dfs(x, y + 1, s);

    // 放皇后
    if (!row[x] && !col[y] && !dg[x + y] && !udg[x - y + n])
    {
        g[x][y] = 'Q';
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = true;
        dfs(x, y + 1, s + 1);
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = false;
        g[x][y] = '.';
    }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            g[i][j] = '.';

    dfs(0, 0, 0);

    return 0;
}
```

[参考https://www.acwing.com/solution/content/2820/](https://www.acwing.com/solution/content/2820/)



### 深搜代码框架

```cpp
int ans = 最坏情况, now;  // now为当前答案
void dfs(传入数值) {
  if (到达目的地) ans = 从当前解与已有解中选最优;
  for (遍历所有可能性)
    if (可行) {
      进行操作;
      dfs(缩小规模);
      撤回操作;
    }
}
```



### memoization记忆化(进一步的)

记忆化搜索，是在学习动态规划的时候，用到的。用记忆化搜索的方式，实现dp。在这个章节，练习题目时，也请感受一下记忆化操作。

```cpp
//记忆化模板

int g[MAXN];  // 定义记忆化数组
int ans = 最坏情况, now;
void dfs f(传入数值) {
  if (g[规模] != 无效数值) return;  // 或记录解，视情况而定
  if (到达目的地) ans = 从当前解与已有解中选最优;  // 输出解，视情况而定
  for (遍历所有可能性)
    if (可行) {
      进行操作;
      dfs(缩小规模);
      撤回操作;
    }
}
int main() {
  ... memset(g, 无效数值, sizeof(g));  // 初始化记忆化数组
  ...
}
```



### 《一本通》题目

##### [【例5.2】组合的输出](http://ybt.ssoier.cn:8088/problem_show.php?pid=1317)

递归实现组合枚举

##### [【例5.3】自然数的拆分](http://ybt.ssoier.cn:8088/problem_show.php?pid=1318)

拆分成若干个小于n的自然数之和

##### [LETTERS](http://ybt.ssoier.cn:8088/problem_show.php?pid=1212)

棋盘上dfs

##### [八皇后问题](http://ybt.ssoier.cn:8088/problem_show.php?pid=1213)

92种方案

##### [八皇后](http://ybt.ssoier.cn:8088/problem_show.php?pid=1214)

输出第x种方案

##### [迷宫](http://ybt.ssoier.cn:8088/problem_show.php?pid=1215)

棋盘上dfs，判断是否可达。注意是不用回溯

##### [红与黑](http://ybt.ssoier.cn:8088/problem_show.php?pid=1216)

总共能到达多少块黑色瓷砖

##### [棋盘问题](http://ybt.ssoier.cn:8088/problem_show.php?pid=1217)

棋盘形状是不规则的，只能在 # 位置上摆放。两个棋子不能同行同列，摆放k个棋子，有多少种方案。设计一个带参数的dfs函数

```cpp
void dfs(int u, int num) 枚举到第u行，已经摆放了num个棋子
    
for (int i = u; i < n; i++)
    for (int j = 0; j < n; j++){
    	if (!col[j] && g[i][j] == '#'){
			col[j] = true;
            dfs(i + 1, num + 1);
            col[j] = false;
        }
    }
```

##### [取石子游戏](http://ybt.ssoier.cn:8088/problem_show.php?pid=1218)

从较多的那堆里取，去较少那堆的整数倍，最后把一堆棋子取空，就是赢家。多组数据，问先手是不是赢家。

a / b >= 2, 先手必胜。

a / b < 2, 先手只有一种取法。

>  a / b >= 2，先手必胜。神奇的性质。

##### [马走日](http://ybt.ssoier.cn:8088/problem_show.php?pid=1219)

给出起始位置，问有多少方案可以遍历到棋盘上的所有点。

```cpp
void dfs(int x, int y, int num) //num是已经遍历点的个数
```

用数组控制8个方向的写法，判断点合法性的方法

##### [单词接龙](http://ybt.ssoier.cn:8088/problem_show.php?pid=1220)【难】

要拼成的单词长度尽可能的长，两个单词重合的部分就会尽可能的少。

```cpp
if (a.substr(a.size() - k, k) == b.substr(0, k))
用g[i][j] = k 维护两个单词之间重叠关系
    
void dfs(string dragon, int last){
	//...
	vis[last]++;

	for (int i = 0; i < n; i++)
		if (g[last][i] && vis[i] < 2)
			dfs(dragon + s[i].substr(g[last][i]), i); 

	vis[last]--;
    //...
}

//调用
dfs(s[i], i);
```

##### [分成互质组](http://ybt.ssoier.cn:8088/problem_show.php?pid=1221)【难】

方法一：拿着鸡蛋去往篮子里放，有合适的放或者不放，没有合适的就先开一个篮子

//爆搜，每一个位置有两种操作
//对已有的每一个组进行枚举，看能不能放进去
//新建一个组，放进去

方法二：鸡蛋一排摆在地上，拿着篮子去挑鸡蛋

```cpp
void dfs(int g, int gc, int tc, int start) //group count    total count
{
	if (g >= res) return ;
	if (tc == n) res = min(res, g);

	bool flag = true;
	for (int i = start; i < n; i++)
		if (!st[i] && check(group[g], gc, i)){  //传进去的是一个一维数组
			st[i] = true;
			group[g][gc] = i;
			dfs(g, gc + 1, tc + 1, i + 1);
			st[i] = false;

			flag = false;
		}

	if (flag) dfs(g + 1, 0, tc, 0);  //从0号下标开始搜
}

//调用
dfs(1, 0, 0, 0);
```

##### [放苹果](http://ybt.ssoier.cn:8088/problem_show.php?pid=1222)

苹果数量大于盘子数量，第n个盘子不放dfs(m, n - 1)，每个盘子都放一个dfs(m - n, n)

苹果数量小于盘子数量，问题等价于dfs(m, m)

问题边界：0个苹果，1种放法。1个盘子，1种放法。



### 示例程序

```cpp
//将正整数n分解成 小于等于m个 正整数之和，且排在后面的数必须大于等于前面的数，并输出所有方案
//问题2的递归实现
#include <bits/stdc++.h>

using namespace std;

int n, m;
int a[110];

void dfs(int left, int u, int prev)
{
	if (left == 0){
		for (int i = 1; i < u; i++) printf("%d ", a[i]);
		puts("");

		return ;
	}

	if (u > m) return ;

	for (int i = prev; i <= left; i++){
		a[u] = i;
		dfs(left - i, u + 1, i);
	}
}

int main()
{
	cin >> n >> m;
	dfs(n, 1, 1);  //剩余n可分配，当前第1位，可以从1开始用

	return 0;
}
```

```cpp
//把n恰好分成m个正整数的方案，问题1的递归实现
#include <bits/stdc++.h>

using namespace std;

int n, m;
int a[110];

void dfs(int left, int u, int prev)
{
	if (left == 0){
		if (u == m + 1){
			for (int i = 1; i < u; i++) printf("%d ", a[i]);
			puts("");
		}

		return ;
	}

	if (u > m) return ;

	for (int i = prev; i <= left; i++){
		a[u] = i;
		dfs(left - i, u + 1, i);
	}
}

int main()
{
	cin >> n >> m;
	dfs(n, 1, 1);  //剩余n可分配，当前第1位，可以从1开始用

	return 0;
}
```

```cpp
//重新设计一个dfs函数，这回是带用了多少作为参数
//把n恰好分成m个正整数的方案，问题1的递归实现
#include <bits/stdc++.h>

using namespace std;

int n, m;
int A[110];

void dfs(int u, int sum, int a)  //当前第u个，已经分配了sum，可以从a开始用
{
	if (u == m + 1)
	{
		if (sum == n){
			for (int i = 1; i <= m; i++) printf("%d ", A[i]);
			puts("");
		}

		return ;
	}

	for (int j = a; j <= n; j++){
		A[u] = j;
		dfs(u + 1, sum + j, j);
	}
}

int main()
{
	cin >> n >> m;
	dfs(1, 0, 1); 
	return 0;
}
```

