

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>15. trees树(一) &mdash; 信息学奥赛普及组算法21天突破 0.7.1 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="16. trees树(二)" href="%E6%A0%91%E4%BA%8C.html" />
    <link rel="prev" title="14. queue队列" href="%E9%98%9F%E5%88%97.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> 信息学奥赛普及组算法21天突破
          

          
          </a>

          
            
            
              <div class="version">
                0.7.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">一、普及组算法部分</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="%E5%BA%8F%E8%A8%80.html">1. preface序言</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html">2. time complexity时间复杂度</a></li>
<li class="toctree-l1"><a class="reference internal" href="STL.html">3. data structure(STL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%AB%98%E7%B2%BE%E5%BA%A6.html">4. high accuracy高精度</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%8E%92%E5%BA%8F.html">5. sortings排序</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%80%92%E6%8E%A8.html">6. recursion 递推</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%80%92%E5%BD%92.html">7. recursive 递归</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF.html">8. complete search and backtracking 搜索与回溯</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E8%B4%AA%E5%BF%83.html">9. greedy algorithm 贪心</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%88%86%E6%B2%BB.html">10. divide and conquer分治</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.html">11. bfs宽度优先搜索</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html">12. dp动态规划</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%A0%88.html">13. stack栈</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%98%9F%E5%88%97.html">14. queue队列</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">15. trees树(一)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#tree-traversal">15.1. Tree traversal树的遍历</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dynamic-programmingdp">15.2. Dynamic programming使用dp求子树大小</a></li>
<li class="toctree-l2"><a class="reference internal" href="#diameter">15.3. Diameter树的直径</a></li>
<li class="toctree-l2"><a class="reference internal" href="#binary-trees">15.4. Binary trees二叉树</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">15.5. 《一本通》题目</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">15.5.1. 【例3-1】找树根和孩子</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">15.5.2. 【例3-2】单词查找树</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">15.5.2.1.  【例3-3】医院设置</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id5">15.5.3. 【例3-4】求后序遍历</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">15.5.4. 【例3-5】扩展二叉树</a></li>
<li class="toctree-l3"><a class="reference internal" href="#drop">15.5.5. 小球(drop)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#flist">15.5.6. 二叉树遍历(flist)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fbi-fbi">15.5.7. FBI树(fbi)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#btout">15.5.8. 二叉树输出(btout)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tree-a">15.5.9. 查找二叉树(tree_a)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tree-c">15.5.10. 对称二叉树(tree_c)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fruit">15.5.11. 合并果子(fruit)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#minval">15.5.12. 最小函数值(minval)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">15.5.13. 看病</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">15.5.14. 小明的账单</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fishing">15.5.15. 鱼塘钓鱼(fishing）</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="%E6%A0%91%E4%BA%8C.html">16. trees树(二)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%9B%BE%E8%AE%BA%E4%B8%80.html">17. graph图论(一)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%9B%BE%E8%AE%BA%E4%BA%8C.html">18. graph图论(二)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%9B%BE%E8%AE%BA%E4%B8%89.html">19. graph图论(三)</a></li>
</ul>
<p class="caption"><span class="caption-text">二、计算机使用教程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C.html">1. Windows环境下的操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/macOS%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C.html">2. macOS环境下的操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E4%BB%A3%E7%A0%81%E7%BB%8F%E9%AA%8C.html">3. 代码经验</a></li>
</ul>
<p class="caption"><span class="caption-text">三、C++语言部分</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/endl.html">1. end and flushing the buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html">2. 输入输出</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">信息学奥赛普及组算法21天突破</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">15. </span>trees树(一)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/算法/树一.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="trees">
<h1><span class="section-number">15. </span>trees树(一)<a class="headerlink" href="#trees" title="Permalink to this headline">¶</a></h1>
<p>注：先学习图，再学习本章节。</p>
<p>A <strong>tree</strong> is a connected, acyclic graph that consists of <em>n</em> nodes and <em>n</em> − 1 edges. Removing any edge from a tree divides it into two components, and adding any edge to a tree creates a cycle. Moreover, there is always a unique path between any two nodes of a tree.（树是图的一部分，连通的，无环，有n个顶点，n-1条边）</p>
<p>The <strong>leaves</strong> of a tree are the nodes with degree 1, i.e., with only one neighbor.</p>
<p>In a <strong>rooted</strong> tree, one of the nodes is appointed the <strong>root</strong> of the tree, and all other nodes are placed underneath the root. For example, in the following tree, node 1 is the root node.</p>
<center><p><img alt="../_images/image-20210204152542021.png" src="../_images/image-20210204152542021.png" /></p>
</center><p>In a rooted tree, the <strong>children</strong> of a node are its lower neighbors, and the <strong>parent</strong> of a node is its upper neighbor. Each node has exactly one parent, except for the root that does not have a parent. For example, in the above tree, the children of node 2 are nodes 5 and 6, and its parent is node 1.</p>
<p>The structure of a rooted tree is <em>recursive</em>: each node of the tree acts as the root of a <strong>subtree</strong> that contains the node itself and all nodes that are in the subtrees of its children. For example, in the above tree, the subtree of node 2 consists of nodes 2, 5, 6 and 8:</p>
<center><p><img alt="../_images/image-20210204152709289.png" src="../_images/image-20210204152709289.png" /></p>
</center><div class="section" id="tree-traversal">
<h2><span class="section-number">15.1. </span>Tree traversal树的遍历<a class="headerlink" href="#tree-traversal" title="Permalink to this headline">¶</a></h2>
<p>General graph traversal algorithms can be used to traverse the nodes of a tree. However, the traversal of a tree is easier to implement than that of a general graph, because there are no cycles in the tree and it is not possible to reach a node from multiple directions.</p>
<p>The typical way to traverse a tree is to start a depth-first search at an arbitrary node. The following recursive function can be used:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//e代表父亲节点</span>
    <span class="c1">// process node s</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">u</span> <span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="p">{</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="n">e</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function is given two parameters: the current node <em>s</em> and the previous node <em>e</em>. The purpose of the parameter <em>e</em> is to make sure that the search only moves to nodes that have not been visited yet.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//In the first call e = 0, because there is no previous node, and it is allowed to proceed to any direction in the tree.</span>
	<span class="n">dfs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="dynamic-programmingdp">
<h2><span class="section-number">15.2. </span>Dynamic programming使用dp求子树大小<a class="headerlink" href="#dynamic-programmingdp" title="Permalink to this headline">¶</a></h2>
<p>Dynamic programming can be used to calculate some information during a tree traversal. Using dynamic programming, we can, for example, calculate in <em>O</em>(<em>n</em>) time for each node of a rooted tree the number of nodes in its subtree or the length of the longest path from the node to a leaf.</p>
<p>As an example, let us calculate for each node <em>s</em> a value count[<em>s</em>]: the number of nodes in its subtree. The subtree contains the node itself and all nodes in the subtrees of its children, so we can calculate the number of nodes recursively using the following code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">u</span> <span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="p">{</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">e</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
       <span class="n">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
       <span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">count</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
	<span class="p">}</span> 
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="diameter">
<h2><span class="section-number">15.3. </span>Diameter树的直径<a class="headerlink" href="#diameter" title="Permalink to this headline">¶</a></h2>
<p>The <strong>diameter</strong> of a tree is the maximum length of a path between two nodes. Forexample, consider the following tree:</p>
<center><p><img alt="../_images/image-20210204153506250.png" src="../_images/image-20210204153506250.png" /></p>
</center><p>Note that there may be several maximum-length paths. In the above path, we could replace node 6 with node 5 to obtain another path with length 4.</p>
<p>Next we will discuss two <strong><em>O</em>(<em>n</em>)</strong> time algorithms for calculating the diameter of a tree. The first algorithm is based on dynamic programming, and the second algorithm uses two depth-first searches.</p>
<p><strong>Algorithm 1</strong></p>
<p>**A general way to approach many tree problems is to first root the tree arbitrarily. After this, we can try to solve the problem separately for each subtree. **Our first algorithm for calculating the diameter is based on this idea.</p>
<p>An important observation is that every path in a rooted tree has a <em>highest point</em>: the highest node that belongs to the path. Thus, we can calculate for each node the length of the longest path whose highest point is the node. One of those paths corresponds to the diameter of the tree.</p>
<p>For example, in the following tree, node 1 is the highest point on the path that corresponds to the diameter:</p>
<center><p><img alt="../_images/image-20210204154113525.png" src="../_images/image-20210204154113525.png" /></p>
</center><p>We calculate for each node <em>x</em> two values:</p>
<ul class="simple">
<li><p>toLeaf(<em>x</em>): the maximum length of a path from <em>x</em> to any leaf</p></li>
<li><p>maxLength(<em>x</em>): the maximum length of a path whose highest point is <em>x</em></p></li>
</ul>
<p>For example, in the above tree, toLeaf(1) = 2, because there is a path 1 → 2 → 6, and maxLength(1)=4, because there is a path 6→2→1→4→7. In this case, maxLength(1) equals the diameter.</p>
<p>Dynamic programming can be used to calculate the above values for all nodes in <em>O</em>(<em>n</em>) time. First, to calculate toLeaf(<em>x</em>), we go through the children of <em>x</em>, choose a child <em>c</em> with maximum toLeaf(<em>c</em>) and add one to this value. Then, to calculate maxLength(<em>x</em>), we choose two distinct children <em>a</em> and <em>b</em> such that the sum toLeaf(<em>a</em>) + toLeaf(<em>b</em>) is maximum and add two to this sum.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//类似floyd呢</span>
<span class="c1">//还没实现过这种写法,要写一下</span>
</pre></div>
</div>
<p><strong>Algorithm 2</strong></p>
<p>Another efficient way to calculate the diameter of a tree is based on two depth- first searches. First, we choose an arbitrary node <em>a</em> in the tree and find the farthest node <em>b</em> from <em>a</em>. Then, we find the farthest node <em>c</em> from <em>b</em>. The diameter of the tree is the distance between <em>b</em> and <em>c</em>.</p>
<p>In the following graph, <em>a</em>, <em>b</em> and <em>c</em> could be:</p>
<center><p><img alt="../_images/image-20210204154340195.png" src="../_images/image-20210204154340195.png" /></p>
</center><p>This is an elegant method, but why does it work?</p>
<p>It helps to draw the tree differently so that the path that corresponds to the diameter is horizontal, and all other nodes hang from it:</p>
<center><p><img alt="../_images/image-20210204154411090.png" src="../_images/image-20210204154411090.png" /></p>
</center><p>Node <em>x</em> indicates the place where the path from node <em>a</em> joins the path that corresponds to the diameter. The farthest node from <em>a</em> is node <em>b</em>, node <em>c</em> or some other node that is at least as far from node <em>x</em>. Thus, this node is always a valid choice for an endpoint of a path that corresponds to the diameter.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//这个更好实现，就是跑两遍dfs</span>
<span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100010</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">h</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="n">N</span> <span class="o">*</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ne</span><span class="p">[</span><span class="n">N</span> <span class="o">*</span> <span class="mi">2</span><span class="p">],</span> <span class="n">w</span><span class="p">[</span><span class="n">N</span> <span class="o">*</span> <span class="mi">2</span><span class="p">],</span> <span class="n">idx</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dep</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">maxn</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">e</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">ne</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">w</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dep</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxn</span><span class="p">)</span> <span class="n">maxn</span> <span class="o">=</span> <span class="n">dep</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">num</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ne</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">fa</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

		<span class="n">dep</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dep</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="p">;</span> <span class="n">id</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">h</span><span class="p">);</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
			<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d%d%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">);</span>

			<span class="n">a</span><span class="o">++</span><span class="p">,</span> <span class="n">b</span><span class="o">++</span><span class="p">;</span>
			<span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
			<span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
		<span class="p">}</span>
		
		<span class="n">maxn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">dep</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">dep</span><span class="p">);</span>
		<span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		
		<span class="n">maxn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">dep</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">dep</span><span class="p">);</span>
		<span class="n">dfs</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Case %d: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">maxn</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="binary-trees">
<h2><span class="section-number">15.4. </span>Binary trees二叉树<a class="headerlink" href="#binary-trees" title="Permalink to this headline">¶</a></h2>
<p>A <strong>binary tree</strong> is a rooted tree where each node has a left and right subtree. It is possible that a subtree of a node is empty. Thus, every node in a binary tree has zero, one or two children.</p>
<p>For example, the following tree is a binary tree:</p>
<center><p><img alt="../_images/image-20210204161911728.png" src="../_images/image-20210204161911728.png" /></p>
</center><p>The nodes of a binary tree have three natural orderings that correspond to different ways to recursively traverse the tree:</p>
<ul class="simple">
<li><p><strong>pre-order</strong>: first process the root, then traverse the left subtree, then traverse the right subtree</p></li>
<li><p><strong>in-order</strong>: first traverse the left subtree, then process the root, then traverse the right subtree</p></li>
<li><p><strong>post-order</strong>: first traverse the left subtree, then traverse the right subtree, then process the root</p></li>
</ul>
<p>For the above tree, the nodes in pre-order are [1,2,4,5,6,3,7], in in-order [4,2,6,5,1,3,7] and in post-order [4,6,5,2,7,3,1].</p>
<p>If we know <strong>the pre-order and in-order</strong> of a tree, we can reconstruct the exact structure of the tree. For example, the above tree is the only possible tree with pre-order [1, 2, 4, 5, 6, 3, 7] and in-order [4, 2, 6, 5, 1, 3, 7]. In a similar way, <strong>the post-order and in-order</strong> also determine the structure of a tree.</p>
<p>However, the situation is different if we only know the pre-order and post- order of a tree. In this case, there may be more than one tree that match the orderings. For example, in both of the trees the pre-order is [1,2] and the post-order is [2,1], but the structures of the trees are different.</p>
<center><p><img alt="../_images/image-20210204162024821.png" src="../_images/image-20210204162024821.png" /></p>
</center></div>
<div class="section" id="id1">
<h2><span class="section-number">15.5. </span>《一本通》题目<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id2">
<h3><span class="section-number">15.5.1. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1336">【例3-1】找树根和孩子</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//fa[N]维护每个结点的父亲，如果一个节点没有fa，他就是根</span>
<span class="c1">//son[N]维护孩子个数</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3><span class="section-number">15.5.2. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1337">【例3-2】单词查找树</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//trie树，可以高效的存储和查找字符串</span>
</pre></div>
</div>
<div class="section" id="id4">
<h4><span class="section-number">15.5.2.1. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1338"> 【例3-3】医院设置</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//floyd维护出任意两点的距离</span>
<span class="c1">//枚举医院的位置，更新res</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h3><span class="section-number">15.5.3. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1339">【例3-4】求后序遍历</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//给出先序和中序，求后续</span>
<span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">l1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r2</span><span class="p">)</span>
<span class="c1">//根据先序l1位置的根，去找中序中根的位置</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3><span class="section-number">15.5.4. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1340">【例3-5】扩展二叉树</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//给出扩展二叉树的先序序列，输出中序和后序</span>
<span class="c1">//题解给出的是指针写法【指针】</span>
</pre></div>
</div>
</div>
<div class="section" id="drop">
<h3><span class="section-number">15.5.5. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1363">小球(drop)</a><a class="headerlink" href="#drop" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//起初所有节点都是false，访问这个点就会设置成相反状态</span>
<span class="c1">//求第i个小球停在哪个叶子结点上</span>
<span class="c1">//方法1，模拟1...i个小球的下落过程</span>
<span class="c1">//方法2，根据左儿子pos*2，右儿子pos*2+1</span>
<span class="c1">//开一个一维数组，维护结点的true和false</span>
</pre></div>
</div>
</div>
<div class="section" id="flist">
<h3><span class="section-number">15.5.6. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1364">二叉树遍历(flist)</a><a class="headerlink" href="#flist" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//给出中序序列和按层序列，求先序序列</span>
<span class="c1">//在按层遍历序列中先遇到根，在中序序列中，找到根的位置，break出来</span>
<span class="c1">//进行递归处理</span>
<span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">l1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="fbi-fbi">
<h3><span class="section-number">15.5.7. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1365">FBI树(fbi)</a><a class="headerlink" href="#fbi-fbi" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//边界</span>
    
    <span class="c1">//子问题</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">dfs</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">dfs</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	
    <span class="c1">//按题意模拟操作</span>
<span class="p">}</span>    
</pre></div>
</div>
</div>
<div class="section" id="btout">
<h3><span class="section-number">15.5.8. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1366">二叉树输出(btout)</a><a class="headerlink" href="#btout" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//给出先序和中序，求凹入表示</span>
<span class="kt">int</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">l1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r2</span><span class="p">)</span>
<span class="c1">//照样递归下去，dfs返回的是子树大小，用son[N]维护每个结点的子树大小</span>
</pre></div>
</div>
</div>
<div class="section" id="tree-a">
<h3><span class="section-number">15.5.9. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1367">查找二叉树(tree_a)</a><a class="headerlink" href="#tree-a" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//题意是，中序遍历的顺序，值为target的结点是第几个被遍历到的</span>
</pre></div>
</div>
</div>
<div class="section" id="tree-c">
<h3><span class="section-number">15.5.10. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1368">对称二叉树(tree_c)</a><a class="headerlink" href="#tree-c" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//思路1，从s[1]开始，两两为一单位，要么都是#，要么都不是#</span>
<span class="c1">//思路2，根据左儿子和右儿子的位置，去判断左右儿子要么同时为#，要么同时不是#</span>
<span class="c1">//两个思路，都需要在读入的字符串后面加上一个#，避免最后一个叶子结点没有兄弟的情况</span>
</pre></div>
</div>
</div>
<div class="section" id="fruit">
<h3><span class="section-number">15.5.11. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1369">合并果子(fruit)</a><a class="headerlink" href="#fruit" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//小根堆</span>
</pre></div>
</div>
</div>
<div class="section" id="minval">
<h3><span class="section-number">15.5.12. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1370">最小函数值(minval)</a><a class="headerlink" href="#minval" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//用一个大根堆，维护前m个较小值</span>
<span class="c1">//如果堆的大小&gt;=m，新读入的数字，比堆顶小，就更新维护进来</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3><span class="section-number">15.5.13. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1371">看病</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//priority_queue&lt;node&gt; q;自定义结构体使用优先队列</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3><span class="section-number">15.5.14. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1372">小明的账单</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//每天付最大账单和最小账单</span>
<span class="c1">//使用multiset维护</span>
</pre></div>
</div>
</div>
<div class="section" id="fishing">
<h3><span class="section-number">15.5.15. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1373">鱼塘钓鱼(fishing）</a><a class="headerlink" href="#fishing" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//这道题目的处理思路，在另外一个题目也遇到过</span>
<span class="c1">//类似的操作是，把路程消耗先消耗掉，然后就可以看做随意跳来跳去的</span>

<span class="c1">//枚举最远走到的池塘位置，先把路上消耗的时间先减去</span>
<span class="c1">//然后就可以看做已经走过的池塘，可以任意流窜</span>
<span class="c1">//把已经走过的池塘，每一分钟可以钓的鱼，维护到一个大根堆中</span>
<span class="c1">//然后就变成，有限的时间，取有限次，每次都是取最大值(greedy)</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="%E6%A0%91%E4%BA%8C.html" class="btn btn-neutral float-right" title="16. trees树(二)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="%E9%98%9F%E5%88%97.html" class="btn btn-neutral float-left" title="14. queue队列" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, zqiceberg.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>