

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>17. graph图论(三) &mdash; 信息学奥赛普及组算法21天突破 0.7.1 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="18. trees树(一)" href="%E6%A0%91%E4%B8%80.html" />
    <link rel="prev" title="16. graph图论(二)" href="%E5%9B%BE%E8%AE%BA%E4%BA%8C.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> 信息学奥赛普及组算法21天突破
          

          
          </a>

          
            
            
              <div class="version">
                0.7.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">一、普及组算法部分</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="%E5%BA%8F%E8%A8%80.html">1. preface序言</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html">2. time complexity时间复杂度</a></li>
<li class="toctree-l1"><a class="reference internal" href="STL.html">3. data structure(STL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%AB%98%E7%B2%BE%E5%BA%A6.html">4. high accuracy高精度</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%8E%92%E5%BA%8F.html">5. sortings排序</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%80%92%E6%8E%A8.html">6. recursion 递推</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%80%92%E5%BD%92.html">7. recursive 递归</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF.html">8. complete search and backtracking 搜索与回溯</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E8%B4%AA%E5%BF%83.html">9. greedy algorithm 贪心</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%88%86%E6%B2%BB.html">10. divide and conquer分治</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.html">11. bfs宽度优先搜索</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html">12. dp动态规划</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%A0%88.html">13. stack栈</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%98%9F%E5%88%97.html">14. queue队列</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%9B%BE%E8%AE%BA%E4%B8%80.html">15. graph图论(一)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%9B%BE%E8%AE%BA%E4%BA%8C.html">16. graph图论(二)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">17. graph图论(三)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#spanning-tree">17.1. spanning tree生成树</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#kruskals-algorithm">17.1.1. Kruskal’s algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#union-find-structure">17.1.2. Union-find structure并查集</a></li>
<li class="toctree-l3"><a class="reference internal" href="#prims-algorithm">17.1.3. Prim’s algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">17.1.4. 最小生成树知识结构图</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#directed-graphs">17.2. Directed graphs有向图</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#topological-sorting">17.2.1. Topological sorting拓扑序</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dynamic-programming">17.2.2. Dynamic programming</a></li>
<li class="toctree-l3"><a class="reference internal" href="#successor-paths">17.2.3. Successor paths后继路径</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#paths-and-circuits">17.3. Paths and circuits路径和回路</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#eulerian-paths">17.3.1. Eulerian paths欧拉路径，一笔画问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hamiltonian-paths">17.3.2. Hamiltonian paths哈密尔顿路径</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="%E6%A0%91%E4%B8%80.html">18. trees树(一)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%A0%91%E4%BA%8C.html">19. trees树(二)</a></li>
</ul>
<p class="caption"><span class="caption-text">二、计算机使用教程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Focused%20vs%20Diffused%20Thinking%3A%20Solve%20Hard%20Problems%20with%20this%20Simply%20Trick.html">1. Focused vs Diffused Thinking: Solve Hard Problems with this Simply Trick</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/NOI%E5%A4%A7%E7%BA%B2.html">2. NOI大纲</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Thinking%20-%20Brainsotrm%20-%20Rank%20-%20Approach%20.html">3. Thinking - Brainsotrm - Rank - Approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Thinking%20-%20Problem%20Simplification.html">4. Thinking - Problem Simplification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C.html">5. Windows环境下的操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/macOS%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C.html">6. macOS环境下的操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E4%B8%AD%E5%AD%A6%E8%B6%85%E5%89%8D%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%8E%86%E5%AF%B9%E5%A4%A7%E5%AD%A6%E6%8B%94%E5%B0%96%E5%AD%A6%E7%94%9F%E5%AD%A6%E4%B9%A0%E7%8A%B6%E6%80%81%E7%9A%84%E5%BD%B1%E5%93%8D.html">7. 中学超前学习经历对大学拔尖学生学习状态的影响</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E4%BB%A3%E7%A0%81%E7%BB%8F%E9%AA%8C.html">8. 代码经验</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E4%BF%A1%E6%81%AF%E5%AD%A6%E6%AF%94%E8%B5%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html">9. 信息学比赛常见问题</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E5%85%B3%E4%BA%8E%E6%AF%8F%E5%A4%A9%E6%89%93%E5%8D%A1%E7%9A%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%BC%8F.html">10. 关于每天打卡的训练模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E5%8C%97%E5%A4%A7%E6%9D%8E%E6%99%93%E6%98%8E%E6%95%99%E6%8E%88%EF%BC%9A%E4%BB%8E%E8%B6%A3%E5%91%B3%E6%95%B0%E5%AD%A6%E5%88%B0%E8%B6%A3%E5%91%B3%E7%AE%97%E6%B3%95%E5%88%B0%E8%B6%A3%E5%91%B3%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E9%9D%9E%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0%E8%80%85%E4%BD%93%E4%BC%9A%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E7%9A%84%E4%B8%80%E6%9D%A1%E9%80%94%E5%BE%84%EF%BC%9F.html">11. 北大李晓明教授：从趣味数学到趣味算法到趣味编程——非专业学习者体会计算思维的一条途径？</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E5%AF%B9%E8%AF%9DIOI2021%E5%9B%BD%E5%AE%B6%E9%98%9F%E6%88%90%E5%91%98%EF%BC%81%E7%9B%B4%E6%92%AD%E8%B6%85%E8%AF%A6%E7%BB%86%E6%96%87%E5%AD%97%E7%8F%8D%E8%97%8F%E7%89%88%E6%9D%A5%E5%95%A6.html">12. 对话IOI2021国家队成员！直播超详细文字珍藏版来啦</a></li>
</ul>
<p class="caption"><span class="caption-text">三、C++语言部分</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/endl.html">1. end and flushing the buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/int%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E6%98%AF-2%5E31~2%5E31-1.html">2. int型数据类型为什么取值范围是-2^31~2^31-1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E4%B8%80%E3%80%81C%2B%2B%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8.html">3. C++语言入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E4%B8%89%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html">4. 控制结构程序设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html">5. 顺序结构程序设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E4%BA%94%E3%80%81%E6%95%B0%E7%BB%84.html">6. 数组</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E5%85%AD%E3%80%81%E5%87%BD%E6%95%B0.html">7. 函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E5%9B%9B%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html">8. 循环结构程序设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html">9. 输入输出</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">信息学奥赛普及组算法21天突破</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">17. </span>graph图论(三)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/算法/图论三.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="graph">
<h1><span class="section-number">17. </span>graph图论(三)<a class="headerlink" href="#graph" title="Permalink to this headline">¶</a></h1>
<div class="section" id="spanning-tree">
<h2><span class="section-number">17.1. </span>spanning tree生成树<a class="headerlink" href="#spanning-tree" title="Permalink to this headline">¶</a></h2>
<p>A <strong>spanning tree</strong> of a graph consists of all nodes of the graph and some of the edges of the graph so that there is a path between any two nodes. Like trees in general, spanning trees are <strong>connected(连通的) and acyclic(无环)</strong>. Usually there are several ways to construct a spanning tree.</p>
<p>A <strong>minimum spanning tree(最小生成树)</strong> is a spanning tree whose weight is as small as possible.</p>
<p>In a similar way, a <strong>maximum spanning tree(最大生成树)</strong> is a spanning tree whose weight is as large as possible.</p>
<center><p><img alt="../_images/image-20210215234254997.png" src="../_images/image-20210215234254997.png" /></p>
</center><div class="section" id="kruskals-algorithm">
<h3><span class="section-number">17.1.1. </span>Kruskal’s algorithm<a class="headerlink" href="#kruskals-algorithm" title="Permalink to this headline">¶</a></h3>
<p>In <strong>Kruskal’s algorithm</strong>, the initial spanning tree only contains the nodes of the graph and does not contain any edges. Then the algorithm goes through the edges ordered by their weights, and always adds an edge to the tree if it does not create a cycle.</p>
<p>The algorithm maintains the components of the tree. Initially, each node of the graph belongs to a separate component. Always when an edge is added to the tree, two components are joined. Finally, all nodes belong to the same component, and a minimum spanning tree has been found.</p>
<center><p><img alt="../_images/image-20210216151402775.png" src="../_images/image-20210216151402775.png" /></p>
</center><p>The first step of the algorithm is to sort the edges in increasing order of their weights. The result is the following list:</p>
<p><img alt="../_images/image-20210216151430863.png" src="../_images/image-20210216151430863.png" /></p>
<p>After this, the algorithm goes through the list and adds each edge to the tree if it joins two separate components.Initially, each node is in its own component:</p>
<center><p><img alt="../_images/image-20210216151502142.png" src="../_images/image-20210216151502142.png" /></p>
</center><p>The first edge to be added to the tree is the edge 5–6 that creates a component {5,6} by joining the components {5} and {6}.</p>
<center><p><img alt="../_images/image-20210216151526339.png" src="../_images/image-20210216151526339.png" /></p>
</center><p>After this, the edges 1–2, 3–6 and 1–5 are added in a similar way.</p>
<center><p>!<img alt="../_images/image-20210216151604215.png" src="../_images/image-20210216151604215.png" /></p>
</center><p>After those steps, most components have been joined and there are two components in the tree: {1,2,3,5,6} and {4}.</p>
<p>The next edge in the list is the edge 2–3, but it will not be included in the tree, because nodes 2 and 3 are already in the same component. For the same reason, the edge 2–5 will not be included in the tree.</p>
<p>Finally, the edge 4–6 will be included in the tree:</p>
<center><p><img alt="../_images/image-20210216151629848.png" src="../_images/image-20210216151629848.png" /></p>
</center><p>After this, the algorithm will not add any new edges, because the graph is connected and there is a path between any two nodes. The resulting graph is a minimum spanning tree with weight 2+3+3+5+7=20.</p>
<p><strong>Why does this work?</strong></p>
<p>It is a good question why Kruskal’s algorithm works. Why does the greedy strategy guarantee that we will find a minimum spanning tree?</p>
<p>Let us see what happens if the minimum weight edge of the graph is <em>not</em> included in the spanning tree. For example, suppose that a spanning tree for the previous graph would not contain the minimum weight edge 5–6. We do not know the exact structure of such a spanning tree, but in any case it has to contain some edges. Assume that the tree would be as follows:</p>
<center><p><img alt="../_images/image-20210216151652060.png" src="../_images/image-20210216151652060.png" /></p>
</center><p>However, it is not possible that the above tree would be a minimum spanning tree for the graph. The reason for this is that we can remove an edge from the tree and replace it with the minimum weight edge 5–6. This produces a spanning tree whose weight is <em>smaller</em>:</p>
<center><p><img alt="../_images/image-20210216151715601.png" src="../_images/image-20210216151715601.png" /></p>
</center><p>For this reason, it is always optimal to include the minimum weight edge in the tree to produce a minimum spanning tree. Using a similar argument, we can show that it is also optimal to add the next edge in weight order to the tree, and so on. Hence, Kruskal’s algorithm works correctly and always produces a minimum spanning tree.</p>
<p><strong>Implementation</strong></p>
<p>When implementing Kruskal’s algorithm, it is convenient to use the edge list representation of the graph. The first phase of the algorithm sorts the edges in the list in <em><em><em>O</em>(<em>m</em>log</em>m</em>)** time. After this, the second phase of the algorithm builds the minimum spanning tree as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(...)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">same</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span> <span class="n">unite</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We will solve the problem using a union-find structure that implements both functions in **<em>O</em>(log <em>n</em>) **time. Thus, the time complexity of Kruskal’s algorithm will be **<em>O</em>(<em>m</em> log <em>n</em>) **after sorting the edge list.</p>
<p><em>此处，O(mlogm), O(mlogn)都是对的</em></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//示例代码</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">200010</span><span class="p">;</span><span class="c1">//SE问题，也可能出现在这里，一般就是边界问题</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="k">struct</span> <span class="n">Edge</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">W</span><span class="p">)</span><span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">W</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span><span class="n">edges</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>   
    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d%d%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">);</span>
        <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="c1">//直接写kruscal, 不用把他单独包起来了</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">edges</span> <span class="o">+</span> <span class="n">m</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">b</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span><span class="p">;</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">p</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">w</span><span class="p">;</span><span class="c1">//最小生成树，所有树边的权重之和</span>
            <span class="n">cnt</span><span class="o">++</span><span class="p">;</span> <span class="c1">//当前加了多少条边</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">puts</span><span class="p">(</span><span class="s">&quot;impossible&quot;</span><span class="p">);</span>
    <span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="union-find-structure">
<h3><span class="section-number">17.1.2. </span>Union-find structure并查集<a class="headerlink" href="#union-find-structure" title="Permalink to this headline">¶</a></h3>
<p>A <strong>union-find structure</strong> maintains a collection of sets. The sets are disjoint, so no element belongs to more than one set. Two <em><em><em>O</em>(log</em>n</em>)** time operations are supported: the unite operation joins two sets, and the find operation finds the representative of the set that contains a given element.</p>
<p><strong>structure数据结构</strong></p>
<p>In a union-find structure, one element in each set is the representative of the set, and there is a chain from any other element of the set to the representative. For example, assume that the sets are {1,4,7}, {5} and {2,3,6,8}:</p>
<center><p><img alt="../_images/image-20210216151814427.png" src="../_images/image-20210216151814427.png" /></p>
</center><p>In this case the representatives of the sets are 4, 5 and 2. We can find the representative of any element by following the chain that begins at the element. For example, the element 2 is the representative for the element 6, because we follow the chain 6 → 3 → 2. Two elements belong to the same set exactly when their representatives are the same.</p>
<p>Two sets can be joined by connecting the representative of one set to the representative of the other set. For example, the sets {1,4,7} and {2,3,6,8} can be joined as follows:</p>
<center><p><img alt="../_images/image-20210216151746411.png" src="../_images/image-20210216151746411.png" /></p>
</center><p>The resulting set contains the elements {1,2,3,4,6,7,8}. From this on, the element 2 is the representative for the entire set and the old representative 4 points to the element 2.</p>
<p>The efficiency of the union-find structure depends on how the sets are joined. It turns out that we can follow a simple strategy: always connect the representa- tive of the <em>smaller</em> set to the representative of the <em>larger</em> set (or if the sets are of equal size, we can make an arbitrary choice). Using this strategy, the length of any chain will be <em><em><em>O</em>(log</em>n</em>)**, so we can find the representative of any element efficiently by following the corresponding chain.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//初始化</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

<span class="c1">//合并</span>
<span class="n">p</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>  
<span class="c1">//或者</span>
<span class="kt">int</span> <span class="n">pa</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">pb</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pa</span> <span class="o">!=</span> <span class="n">pb</span><span class="p">)</span> <span class="n">p</span><span class="p">[</span><span class="n">pa</span><span class="p">]</span> <span class="o">=</span> <span class="n">pb</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>  <span class="c1">//返回x的祖宗结点+路径压缩</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//另外一份模板</span>
<span class="c1">//the array link contains for each element the next element in the chain or the element itself if it is a representative, and the array size indicates for each representative the size of the corresponding set.</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">link</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">unite</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
    <span class="n">size</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+=</span> <span class="n">size</span><span class="p">[</span><span class="n">b</span><span class="p">];</span>
    <span class="n">link</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="prims-algorithm">
<h3><span class="section-number">17.1.3. </span>Prim’s algorithm<a class="headerlink" href="#prims-algorithm" title="Permalink to this headline">¶</a></h3>
<p><strong>Prim’s algorithm</strong> is an alternative method for finding a minimum spanning tree. The algorithm first adds an arbitrary node to the tree. After this, the algorithm always chooses a minimum-weight edge that adds a new node to the tree. Finally, all nodes have been added to the tree and a minimum spanning tree has been found.</p>
<p>Prim’s algorithm resembles Dijkstra’s algorithm. The difference is that Dijkstra’s algorithm always selects an edge whose distance from the starting node is minimum, but Prim’s algorithm simply selects the minimum weight edge that adds a new node to the tree.</p>
<p>Let us consider how Prim’s algorithm works in the following graph:</p>
<center><p><img alt="../_images/image-20210216151843331.png" src="../_images/image-20210216151843331.png" /></p>
</center><p>Initially, there are no edges between the nodes:</p>
<center><p><img alt="../_images/image-20210216151901900.png" src="../_images/image-20210216151901900.png" /></p>
</center><p>An arbitrary node can be the starting node, so let us choose node 1. First, we add node 2 that is connected by an edge of weight 3:</p>
<center><p><img alt="../_images/image-20210216151339300.png" src="../_images/image-20210216151339300.png" /></p>
</center><p>After this, there are two edges with weight 5, so we can add either node 3 or node 5 to the tree. Let us add node 3 first:</p>
<center><p><img alt="../_images/image-20210216151318466.png" src="../_images/image-20210216151318466.png" /></p>
</center><p>The process continues until all nodes have been included in the tree:</p>
<p><img alt="../_images/image-20210216151257358.png" src="../_images/image-20210216151257358.png" /></p>
<p><strong>Implementation</strong></p>
<p>Like Dijkstra’s algorithm, Prim’s algorithm can be efficiently implemented using a priority queue. The priority queue should contain all nodes that can be connected to the current component using a single edge, in increasing order of the weights of the corresponding edges.</p>
<p>The time complexity of Prim’s algorithm is <em><em><em>O</em>(<em>n</em>+<em>m</em>log</em>m</em>)** that equals the time complexity of Dijkstra’s algorithm. In practice, Prim’s and Kruskal’s algorithms are both efficient, and the choice of the algorithm is a matter of taste. Still, most competitive programmers use Kruskal’s algorithm.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//示例代码</span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">510</span><span class="p">,</span> <span class="n">INF</span> <span class="o">=</span> <span class="mh">0x3f3f3f3f</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">g</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dist</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">st</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">prim</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">dist</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">dist</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="n">INF</span><span class="p">)</span> <span class="k">return</span> <span class="n">INF</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">res</span> <span class="o">+=</span> <span class="n">dist</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">g</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
        <span class="n">st</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">g</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d%d%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
        <span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">);</span>  <span class="c1">//无向图是一种特殊的有向图</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">prim</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">INF</span><span class="p">)</span> <span class="n">puts</span><span class="p">(</span><span class="s">&quot;impossible&quot;</span><span class="p">);</span>  <span class="c1">//当前到大距离最小的点的距离都是INF，那就说明图是不连通的</span>
    <span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id1">
<h3><span class="section-number">17.1.4. </span>最小生成树知识结构图<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<center><p><img alt="../_images/image-20210216002511545.png" src="../_images/image-20210216002511545.png" /></p>
</center><p>from yxc</p>
</div>
</div>
<div class="section" id="directed-graphs">
<h2><span class="section-number">17.2. </span>Directed graphs有向图<a class="headerlink" href="#directed-graphs" title="Permalink to this headline">¶</a></h2>
<p>概念：</p>
<ul class="simple">
<li><p><strong>Acyclic graphs</strong>: There are no cycles in the graph, so there is no path from any node to itself.</p></li>
<li><p><strong>Successor graphs</strong>: The outdegree of each node is 1, so each node has a unique successor.</p></li>
<li><p>Directed acyclic graphs are sometimes called <strong>DAG</strong>s.(DAG, 有向无环图)</p></li>
</ul>
<div class="section" id="topological-sorting">
<h3><span class="section-number">17.2.1. </span>Topological sorting拓扑序<a class="headerlink" href="#topological-sorting" title="Permalink to this headline">¶</a></h3>
<p>A <strong>topological sort</strong> is an ordering of the nodes of a directed graph such that if there is a path from node <em>a</em> to node <em>b</em>, then node <em>a</em> appears before node <em>b</em> in the ordering. For example, for the graph one topological sort is [4,1,5,2,3,6]:</p>
<center><p><img alt="../_images/image-20210216150342706.png" src="../_images/image-20210216150342706.png" /></p>
</center><p>An acyclic graph always has a topological sort. However, if the graph contains a cycle, it is not possible to form a topological sort, because no node of the cycle can appear before the other nodes of the cycle in the ordering. It turns out that depth-first search can be used to both check if a directed graph contains a cycle and, if it does not contain a cycle, to construct a topological sort.</p>
<blockquote>
<div><p>topsort就是有向图的宽度优先遍历的应用
拓扑序，不唯一。如要要字典序最小的拓扑序，在遍历入度为0的点的时候，从1开始遍历，并入队</p>
</div></blockquote>
</div>
<div class="section" id="dynamic-programming">
<h3><span class="section-number">17.2.2. </span>Dynamic programming<a class="headerlink" href="#dynamic-programming" title="Permalink to this headline">¶</a></h3>
<p>If a directed graph is acyclic, dynamic programming can be applied to it. For example, we can efficiently solve the following problems concerning paths from a starting node to an ending node:</p>
<ul class="simple">
<li><p>how many different paths are there?</p></li>
<li><p>what is the shortest/longest path?</p></li>
<li><p>what is the minimum/maximum number of edges in a path?</p></li>
<li><p>which nodes certainly appear in any path?</p></li>
</ul>
<p><strong>Counting the number of paths(统计方案数)(应用)</strong></p>
<p>As an example, let us calculate the number of paths from node 1 to node 6 in the following graph:</p>
<center><p><img alt="../_images/image-20210216151203418.png" src="../_images/image-20210216151203418.png" /></p>
</center><p>There are a total of three such paths:</p>
<p>• 1→2→3→6
• 1→4→5→2→3→6
• 1→4→5→3→6</p>
<p>Let paths(<em>x</em>) denote the number of paths from node 1 to node <em>x</em>. As a base case, paths(1) = 1. Then, to calculate other values of paths(<em>x</em>), we may use the recursion where <em>a</em>1,<em>a</em>2,…,<em>ak</em> are the nodes from which there is an edge to <em>x</em>. Since the graph is acyclic, the values of paths(<em>x</em>) can be calculated in the order of a topological sort. A topological sort for the above graph is as follows:</p>
<center><p><img alt="../_images/image-20210216151053424.png" src="../_images/image-20210216151053424.png" /></p>
<p><img alt="../_images/image-20210216151109158.png" src="../_images/image-20210216151109158.png" /></p>
<p><img alt="../_images/image-20210216151131635.png" src="../_images/image-20210216151131635.png" /></p>
</center><p>For example, to calculate the value of paths(3), we can use the formula paths(2) + paths(5), because there are edges from nodes 2 and 5 to node 3. Since paths(2) = 2 and paths(5) = 1, we conclude that paths(3) = 3.</p>
<p><strong>Extending Dijkstra’s algorithm(对dijkstra得到的最短路径，使用dp)(应用)</strong></p>
<p>A by-product of Dijkstra’s algorithm is a directed, acyclic graph that indicates for each node of the original graph the possible ways to reach the node using a shortest path from the starting node. Dynamic programming can be applied to that graph. For example, in the graph the shortest paths from node 1 may use the following edges:</p>
<center><p><img alt="../_images/image-20210216151025797.png" src="../_images/image-20210216151025797.png" /></p>
</center><p>Now we can, for example, calculate the number of shortest paths from node 1 to node 5 using dynamic programming:</p>
<center><p><img alt="../_images/image-20210216150922157.png" src="../_images/image-20210216150922157.png" /></p>
</center><p><strong>Representing problems as graphs(背包问题转化到图上)(应用)</strong></p>
<p>Actually, any dynamic programming problem can be represented as a directed, acyclic graph. In such a graph, each node corresponds to a dynamic programming state and the edges indicate how the states depend on each other.</p>
<p>As an example, consider the problem of forming a sum of money <em>n</em> using coins {<em>c</em>1,<em>c</em>2,…,<em>c</em>k}. In this problem, we can construct a graph where each node corresponds to a sum of money, and the edges show how the coins can be chosen. For example, for coins {1, 3, 4} and <em>n</em> = 6, the graph is as follows:</p>
<center><p><img alt="../_images/image-20210216150755195.png" src="../_images/image-20210216150755195.png" /></p>
</center><p>Using this representation, the shortest path from node 0 to node <em>n</em> corresponds to a solution with the minimum number of coins, and the total number of paths from node 0 to node <em>n</em> equals the total number of solutions.</p>
</div>
<div class="section" id="successor-paths">
<h3><span class="section-number">17.2.3. </span>Successor paths后继路径<a class="headerlink" href="#successor-paths" title="Permalink to this headline">¶</a></h3>
<p>这里介绍successor paths是因为它引出了倍增的应用，需要学习倍增。noip普及组中，还没遇到successor paths的题目。</p>
<p>In successor graphs, the outdegree of each node is 1, <em>i.e., exactly one edge starts at each node</em>. A successor graph consists of one or more components, each of which contains one cycle and some paths that lead to it.</p>
<p>Successor graphs are sometimes called <strong>functional graphs</strong>. The reason for this is that any successor graph corresponds to a function that defines the edges of the graph. The parameter for the function is a node of the graph, and the function gives the successor of that node.</p>
<p><img alt="../_images/image-20210216153224535.png" src="../_images/image-20210216153224535.png" /></p>
<p><img alt="../_images/image-20210216153241697.png" src="../_images/image-20210216153241697.png" /></p>
<p>Since each node of a successor graph has a unique successor, we can also define a function succ(<em>x</em>,<em>k</em>) that gives the node that we will reach if we begin at node <em>x</em> and walk <em>k</em> steps forward. For example, in the above graph succ(4, 6) = 2, because we will reach node 2 by walking 6 steps from node 4:</p>
<p><img alt="../_images/image-20210216153334833.png" src="../_images/image-20210216153334833.png" /></p>
<p>A straightforward way to calculate a value of succ(<em>x</em>,<em>k</em>) is to start at node <em>x</em> and walk <em>k</em> steps forward, which takes <strong><em>O</em>(<em>k</em>)</strong> time. However, using preprocessing, any value of succ(<em>x</em>, <em>k</em>) can be calculated in only <strong><em>O</em>(log <em>k</em>)</strong> time.</p>
<p>The idea is to precalculate all values of succ(<em>x</em>,<em>k</em>) where <em>k</em> is a power of two and at most <em>u</em>, where <em>u</em> is the maximum number of steps we will ever walk. This can be efficiently done, because we can use the following recursion:</p>
<p><img alt="../_images/image-20210216153434044.png" src="../_images/image-20210216153434044.png" /></p>
<p>Precalculating the values takes <em><em><em>O</em>(<em>n</em>log</em>u</em>)** time, because <em><em><em>O</em>(log</em>u</em>)** values are calculated for each node. In the above graph, the first values are as follows:</p>
<p><img alt="../_images/image-20210216153224535.png" src="../_images/image-20210216153224535.png" /></p>
<p><img alt="../_images/image-20210216153626341.png" src="../_images/image-20210216153626341.png" /></p>
<p>After this, any value of succ(<em>x</em>, <em>k</em>) can be calculated by presenting the number of steps <em>k</em> as a sum of powers of two. For example, if we want to calculate the value of succ(<em>x</em>, 11), we first form the representation 11 = 8 + 2 + 1. Using that,</p>
<p><img alt="../_images/image-20210216153651766.png" src="../_images/image-20210216153651766.png" /></p>
<p><img alt="../_images/image-20210216154258776.png" src="../_images/image-20210216154258776.png" /></p>
<p>Such a representation always consists of <strong><em>O</em>(log <em>k</em>)</strong> parts, so calculating a value of succ(<em>x</em>, <em>k</em>) takes <strong><em>O</em>(log <em>k</em>)</strong> time.</p>
</div>
</div>
<div class="section" id="paths-and-circuits">
<h2><span class="section-number">17.3. </span>Paths and circuits路径和回路<a class="headerlink" href="#paths-and-circuits" title="Permalink to this headline">¶</a></h2>
<p>An <strong>Eulerian path</strong> is a path that goes through each edge exactly once.</p>
<p>A <strong>Hamiltonian path</strong> is a path that visits each node exactly once.</p>
<p>While Eulerian and Hamiltonian paths look like similar concepts at first glance, the computational problems related to them are very different. It turns out that there is a simple rule that determines whether a graph contains an Eulerian path, and there is also an efficient algorithm to find such a path if it exists. On the contrary, checking the existence of a Hamiltonian path is a NP-hard problem, and no efficient algorithm is known for solving the problem.</p>
<div class="section" id="eulerian-paths">
<h3><span class="section-number">17.3.1. </span>Eulerian paths欧拉路径，一笔画问题<a class="headerlink" href="#eulerian-paths" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>L. Euler studied such paths in 1736 when he solved the famous Königsberg bridge problem. This was the birth of graph theory.(七座桥问题)</p>
</div></blockquote>
<p>An <strong>Eulerian path</strong>(欧拉路径) is a path that goes exactly once through each edge of the graph. For example, the graph has an Eulerian path from node 2 to node 5:</p>
<p><img alt="../_images/image-20210216204006927.png" src="../_images/image-20210216204006927.png" /></p>
<p>An <strong>Eulerian circuit</strong>(欧拉回路) is an Eulerian path that starts and ends at the same node. For example, the graph has an Eulerian circuit that starts and ends at node 1:</p>
<p><img alt="../_images/image-20210216204225555.png" src="../_images/image-20210216204225555.png" /></p>
<p><strong>Existence</strong></p>
<p>The existence of Eulerian paths and circuits depends on the degrees of the nodes. First, <strong>an undirected graph</strong> has an Eulerian path exactly when all the edges belong to the same connected component and</p>
<ul class="simple">
<li><p>the degree of each node is even(所有点的度数是偶数)(欧拉回路)</p></li>
<li><p>the degree of exactly two nodes is odd, and the degree of all other nodes is even.(有两个点度数是奇数，其他所有点的度数是偶数)(欧拉路径)(奇数点就是起点)</p></li>
<li><p>以上两点满足其一</p></li>
</ul>
<p>In the first case, each Eulerian path is also an Eulerian circuit. In the second case, the odd-degree nodes are the starting and ending nodes of an Eulerian path which is not an Eulerian circuit.</p>
<p><img alt="../_images/image-20210216212405254.png" src="../_images/image-20210216212405254.png" /></p>
<p>nodes 1, 3 and 4 have a degree of 2, and nodes 2 and 5 have a degree of 3. Exactly two nodes have an odd degree, so there is an Eulerian path between nodes 2 and 5, but the graph does not contain an Eulerian circuit.</p>
<p>In <strong>a directed graph</strong>, we focus on indegrees and outdegrees of the nodes. A directed graph contains an Eulerian path exactly when all the edges belong to the same connected component and</p>
<ul class="simple">
<li><p>in each node, the indegree equals the outdegree(所有点出度和入度相等)(欧拉回路)</p></li>
<li><p>in one node, the indegree is one larger than the outdegree, in another node, the outdegree is one larger than the indegree, and in all other nodes, the indegree equals the outdegree.(一个点入度比出点大1，一个点出点比入度大1，其他点入度和出度相等)(欧拉路径)</p></li>
<li><p>以上两点满足其一</p></li>
</ul>
<p>In the first case, each Eulerian path is also an Eulerian circuit, and in the second case, the graph contains an Eulerian path that begins at the node whose outdegree is larger and ends at the node whose indegree is larger.</p>
<p><img alt="../_images/image-20210216212700549.png" src="../_images/image-20210216212700549.png" /></p>
<p>nodes 1, 3 and 4 have both indegree 1 and outdegree 1, node 2 has indegree 1 and outdegree 2, and node 5 has indegree 2 and outdegree 1. Hence, the graph contains an Eulerian path from node 2 to node 5:</p>
<p><img alt="../_images/image-20210216212731106.png" src="../_images/image-20210216212731106.png" /></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//示例代码，一笔画问题</span>
<span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">110</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">g</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">],</span> <span class="n">in</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">vis</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">circuit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]){</span>
			<span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//这条边画掉</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">in</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="n">in</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="kt">int</span> <span class="n">st</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">st</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span><span class="k">break</span><span class="p">;}</span>
	<span class="p">}</span>

	<span class="n">dfs</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">puts</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="hamiltonian-paths">
<h3><span class="section-number">17.3.2. </span>Hamiltonian paths哈密尔顿路径<a class="headerlink" href="#hamiltonian-paths" title="Permalink to this headline">¶</a></h3>
<p>A <strong>Hamiltonian path</strong> is a path that visits each node of the graph exactly once. For example, the graph contains a Hamiltonian path from node 1 to node 3:</p>
<p><img alt="../_images/image-20210216213051686.png" src="../_images/image-20210216213051686.png" /></p>
<p>If a Hamiltonian path begins and ends at the same node, it is called a <strong>Hamil- tonian circuit</strong>. The graph above also has an Hamiltonian circuit that begins and ends at node 1:</p>
<p><img alt="../_images/image-20210216213116983.png" src="../_images/image-20210216213116983.png" /></p>
<p><strong>Construction</strong></p>
<p>Since there is no efficient way to check if a Hamiltonian path exists, it is clear that there is also no method to efficiently construct the path, because otherwise we could just try to construct the path and see whether it exists.</p>
<p>A simple way to search for a Hamiltonian path is to use a backtracking algorithm that goes through all possible ways to construct the path. The time complexity of such an algorithm is at least <strong><em>O</em>(<em>n</em>!)</strong>, because there are <em>n</em>! different ways to choose the order of <em>n</em> nodes.(使用complete search + backtracking直接搜)</p>
<p>A more efficient solution is based on dynamic programming . The idea is to calculate values of a function possible(<em>S</em>,<em>x</em>), where <em>S</em> is a subset of nodes and <em>x</em> is one of the nodes. The function indicates whether there is a Hamiltonian path that visits the nodes of <em>S</em> and ends at node <em>x</em>. It is possible to implement this solution in <strong><em>O</em>(2^<em>n</em> * <em>n</em>^2)</strong> time.(使用状压dp)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//示例代码，《进阶指南》P7，求起点0到终点n-1的最短Hamilton路径</span>
<span class="c1">//使用了状压dp</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">][</span><span class="mi">20</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">hamilton</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="p">[</span><span class="mi">20</span><span class="p">][</span><span class="mi">20</span><span class="p">]){</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">f</span><span class="p">);</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
                    	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
                            	<span class="k">if</span> <span class="p">((</span><span class="n">i</span><span class="o">^</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">k</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
                                    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">^</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
    
    <span class="k">return</span> <span class="n">f</span><span class="p">[(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>                       	
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="%E6%A0%91%E4%B8%80.html" class="btn btn-neutral float-right" title="18. trees树(一)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="%E5%9B%BE%E8%AE%BA%E4%BA%8C.html" class="btn btn-neutral float-left" title="16. graph图论(二)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, zqiceberg.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>