

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>17. graph图论(一) &mdash; 信息学奥赛普及组算法21天突破 0.7.1 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="18. graph图论(二)" href="%E5%9B%BE%E8%AE%BA%E4%BA%8C.html" />
    <link rel="prev" title="16. queue队列" href="%E9%98%9F%E5%88%97.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> 信息学奥赛普及组算法21天突破
          

          
          </a>

          
            
            
              <div class="version">
                0.7.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">一、普及组算法部分</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="%E5%BA%8F%E8%A8%80.html">1. preface序言</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html">2. time complexity时间复杂度</a></li>
<li class="toctree-l1"><a class="reference internal" href="STL.html">3. data structure(STL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%AB%98%E7%B2%BE%E5%BA%A6.html">4. high accuracy高精度</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%8E%92%E5%BA%8F.html">5. sortings排序</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%80%92%E6%8E%A8.html">6. recursion 递推</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%80%92%E5%BD%92.html">7. recursive 递归</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF.html">8. complete search and backtracking 搜索与回溯</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E8%B4%AA%E5%BF%83%E4%B8%80.html">9. greedy algorithm 贪心(一)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E8%B4%AA%E5%BF%83%E4%BA%8C.html">10. greedy algorithm 贪心(二)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%88%86%E6%B2%BB.html">11. divide and conquer分治</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.html">12. bfs宽度优先搜索</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80.html">13. DP动态规划(一)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BA%8C.html">14. DP动态规划(二)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%A0%88.html">15. stack栈</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%98%9F%E5%88%97.html">16. queue队列</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">17. graph图论(一)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#terminology">17.1. terminology术语</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#connectivity">17.1.1. Connectivity连通性</a></li>
<li class="toctree-l3"><a class="reference internal" href="#edge-directions">17.1.2. Edge directions有向边</a></li>
<li class="toctree-l3"><a class="reference internal" href="#edge-weights">17.1.3. Edge weights边权</a></li>
<li class="toctree-l3"><a class="reference internal" href="#neighbors-and-degrees">17.1.4. Neighbors and degrees相邻的两个顶点和顶点的度</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simplicity">17.1.5. Simplicity简单图</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#graph-representation">17.2. Graph representation建图</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#adjacency-list-representation-vector">17.2.1. Adjacency list representation邻接表建图(vector版本)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adjacency-matrix-representation">17.2.2. Adjacency matrix representation邻接矩阵建图</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adjacency-list-representation">17.2.3. Adjacency list representation邻接表建图(一维数组版本)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#graph-traversal">17.3. Graph traversal图的遍历</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#depth-first-search">17.3.1. Depth-first search深度优先遍历</a></li>
<li class="toctree-l3"><a class="reference internal" href="#breadth-first-search">17.3.2. Breadth-first search宽度优先遍历</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id1">17.4. 《一本通》题目</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">17.4.1. 【例题】一笔画问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="#snow">17.4.2. 铲雪车(snow)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fence">17.4.3. 骑马修栅栏(fence)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">17.4.4. 【例4-1】最短路径问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">17.4.5.  【例4-2】牛的旅行</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">17.4.6. 【例4-4】最小花费</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id6">17.4.6.1. 【例4-6】香甜的黄油</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#msner">17.4.7. 信使(msner)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#travel">17.4.8. 最优乘车(travel)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shopth">17.4.9. 最短路径(shopth)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#heatwv">17.4.10. 热浪(heatwv)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#candy">17.4.11. 分糖果(candy)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dijkstra">17.4.12.  城市路(Dijkstra)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spfa">17.4.13. 最短路(Spfa)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spfa-ii">17.4.14.  SPFA(II)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dijkastra-ii">17.4.15. Dijkastra(II)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#floyd">17.4.16.  Floyd</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cdrom">17.4.17. 刻录光盘(cdrom)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bead">17.4.18. 珍珠(bead)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#relation">17.4.19. 【例4-7】亲戚(relation)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">17.4.20. 【例4-8】格子游戏</a></li>
<li class="toctree-l3"><a class="reference internal" href="#group">17.4.21. 团伙(group)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#black">17.4.22. 打击犯罪(black)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#buy">17.4.23. 搭配购买(buy)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gen">17.4.24. 家谱(gen)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">17.4.25. 亲戚</a></li>
<li class="toctree-l3"><a class="reference internal" href="#noi2001">17.4.26. 食物链【NOI2001】</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">17.4.27.  【例4-9】城市公交网建设问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">17.4.28. 【例4-10】最优布线问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="#agrinet">17.4.29. 【例4-11】最短网络(agrinet)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">17.4.30. 【例4-12】家谱树</a></li>
<li class="toctree-l3"><a class="reference internal" href="#net">17.4.31. 局域网(net)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#city">17.4.32. 繁忙的都市(city)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#liaison">17.4.33. 联络员(liaison)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#grid">17.4.34.  连接格点(grid)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">17.4.35. 【例4-13】奖金</a></li>
<li class="toctree-l3"><a class="reference internal" href="#slides">17.4.36. 烦人的幻灯片(slides)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#virus">17.4.37.  病毒(virus)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="%E5%9B%BE%E8%AE%BA%E4%BA%8C.html">18. graph图论(二)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%9B%BE%E8%AE%BA%E4%B8%89.html">19. graph图论(三)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%A0%91%E4%B8%80.html">20. trees树(一)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%A0%91%E4%BA%8C.html">21. trees树(二)</a></li>
</ul>
<p class="caption"><span class="caption-text">二、计算机使用教程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/517.html">1. 517教学经验</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Focused%20vs%20Diffused%20Thinking%3A%20Solve%20Hard%20Problems%20with%20this%20Simply%20Trick.html">2. Focused vs Diffused Thinking: Solve Hard Problems with this Simply Trick</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/NOI%E5%A4%A7%E7%BA%B2.html">3. NOI大纲</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Tackling%20a%20problem%20.html">4. Tackling a problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Thinking%20-%20Brainsotrm%20-%20Rank%20-%20Approach%20.html">5. Thinking - Brainsotrm - Rank - Approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Thinking%20-%20Concretely%2C%20Symbolically%2C%20Pictorially.html">6. Thinking - Concretely, Symbolically, Pictorially</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Thinking%20-%20Problem%20Simplification.html">7. Thinking - Problem Simplification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C.html">8. Windows环境下的操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/macOS%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C.html">9. macOS环境下的操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E4%B8%AD%E5%AD%A6%E8%B6%85%E5%89%8D%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%8E%86%E5%AF%B9%E5%A4%A7%E5%AD%A6%E6%8B%94%E5%B0%96%E5%AD%A6%E7%94%9F%E5%AD%A6%E4%B9%A0%E7%8A%B6%E6%80%81%E7%9A%84%E5%BD%B1%E5%93%8D.html">10. 中学超前学习经历对大学拔尖学生学习状态的影响</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E4%BB%A3%E7%A0%81%E7%BB%8F%E9%AA%8C.html">11. 代码经验</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E4%BF%A1%E6%81%AF%E5%AD%A6%E6%AF%94%E8%B5%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html">12. 信息学比赛常见问题</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E5%85%B3%E4%BA%8E%E6%AF%8F%E5%A4%A9%E6%89%93%E5%8D%A1%E7%9A%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%BC%8F.html">13. 关于每天打卡的训练模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E5%8C%97%E5%A4%A7%E6%9D%8E%E6%99%93%E6%98%8E%E6%95%99%E6%8E%88%EF%BC%9A%E4%BB%8E%E8%B6%A3%E5%91%B3%E6%95%B0%E5%AD%A6%E5%88%B0%E8%B6%A3%E5%91%B3%E7%AE%97%E6%B3%95%E5%88%B0%E8%B6%A3%E5%91%B3%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E9%9D%9E%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0%E8%80%85%E4%BD%93%E4%BC%9A%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E7%9A%84%E4%B8%80%E6%9D%A1%E9%80%94%E5%BE%84%EF%BC%9F.html">14. 北大李晓明教授：从趣味数学到趣味算法到趣味编程——非专业学习者体会计算思维的一条途径？</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E5%AF%B9%E8%AF%9DIOI2021%E5%9B%BD%E5%AE%B6%E9%98%9F%E6%88%90%E5%91%98%EF%BC%81%E7%9B%B4%E6%92%AD%E8%B6%85%E8%AF%A6%E7%BB%86%E6%96%87%E5%AD%97%E7%8F%8D%E8%97%8F%E7%89%88%E6%9D%A5%E5%95%A6.html">15. 对话IOI2021国家队成员！直播超详细文字珍藏版来啦</a></li>
</ul>
<p class="caption"><span class="caption-text">三、C++语言部分</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/endl.html">1. end and flushing the buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/int%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E6%98%AF-2%5E31~2%5E31-1.html">2. int型数据类型为什么取值范围是-2^31~2^31-1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E4%B8%80%E3%80%81C%2B%2B%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8.html">3. C++语言入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E4%B8%89%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html">4. 控制结构程序设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html">5. 顺序结构程序设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E4%BA%94%E3%80%81%E6%95%B0%E7%BB%84.html">6. 数组</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E5%85%AD%E3%80%81%E5%87%BD%E6%95%B0.html">7. 函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E5%9B%9B%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html">8. 循环结构程序设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html">9. 输入输出</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">信息学奥赛普及组算法21天突破</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">17. </span>graph图论(一)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/算法/图论一.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="graph">
<h1><span class="section-number">17. </span>graph图论(一)<a class="headerlink" href="#graph" title="Permalink to this headline">¶</a></h1>
<p>Many programming problems can be solved by modeling the problem as a graph problem and using an appropriate graph algorithm. A typical example of a graph is a network of roads and cities in a country.</p>
<div class="section" id="terminology">
<h2><span class="section-number">17.1. </span>terminology术语<a class="headerlink" href="#terminology" title="Permalink to this headline">¶</a></h2>
<p>A <strong>graph</strong> consists of <strong>nodes</strong> and <strong>edges</strong>. In this book, the variable <em>n</em> denotes the number of nodes in a graph, and the variable <em>m</em> denotes the number of edges. The nodes are numbered using integers 1,2,…,<em>n</em>. 下面这个图，有5个顶点，7条边。</p>
<center><p><img alt="../_images/image-20210128182946646.png" src="../_images/image-20210128182946646.png" /></p>
</center><p>A <strong>path</strong> leads from node <em>a</em> to node <em>b</em> through edges of the graph. The <strong>length</strong> of a path is the number of edges in it. For example, the above graph contains a path 1→3→4→5 of length 3 from node 1 to node 5:</p>
<center><p><img alt="../_images/image-20210128183048974.png" src="../_images/image-20210128183048974.png" /></p>
</center><p>A path is a <strong>cycle</strong> if the first and last node is the same. For example, the above graph contains a cycle 1 → 3 → 4 → 1. A path is <strong>simple</strong> if each node appears at most once in the path.(概念，简单图)</p>
<div class="section" id="connectivity">
<h3><span class="section-number">17.1.1. </span>Connectivity连通性<a class="headerlink" href="#connectivity" title="Permalink to this headline">¶</a></h3>
<p>A graph is <strong>connected</strong> if there is a path between any two nodes. For example, the following graph is connected:</p>
<center><p><img alt="../_images/image-20210128183300876.png" src="../_images/image-20210128183300876.png" /></p>
</center><p>The following graph is not connected, because it is not possible to get from node 4 to any other node:</p>
<center><p><img alt="../_images/image-20210128183343977.png" src="../_images/image-20210128183343977.png" /></p>
</center><p>The connected parts of a graph are called its <strong>components</strong>. For example, the following graph contains three components: {1, 2, 3}, {4, 5, 6, 7} and {8}.</p>
<center><p><img alt="../_images/image-20210128183418819.png" src="../_images/image-20210128183418819.png" /></p>
</center><p>A <strong>tree</strong> is a connected graph that consists of <em>n</em> nodes and <em>n</em> − 1 edges. There is a unique path between any two nodes of a tree. For example, the following graph is a tree:</p>
<center><p><img alt="../_images/image-20210128183443609.png" src="../_images/image-20210128183443609.png" /></p>
</center></div>
<div class="section" id="edge-directions">
<h3><span class="section-number">17.1.2. </span>Edge directions有向边<a class="headerlink" href="#edge-directions" title="Permalink to this headline">¶</a></h3>
<p>A graph is <strong>directed</strong> if the edges can be traversed in one direction only. For example, the following graph is directed:</p>
<center><p><img alt="../_images/image-20210128183527489.png" src="../_images/image-20210128183527489.png" /></p>
</center><p>The above graph contains a path 3→1→2→5 from node 3 to node 5, but there is no path from node 5 to node 3.</p>
<p>无向边，其实，是两条有向边的合并版本</p>
</div>
<div class="section" id="edge-weights">
<h3><span class="section-number">17.1.3. </span>Edge weights边权<a class="headerlink" href="#edge-weights" title="Permalink to this headline">¶</a></h3>
<p>In a <strong>weighted</strong> graph, each edge is assigned a <strong>weight</strong>. The weights are often interpreted as edge lengths. For example, the following graph is weighted:</p>
<center><p><img alt="../_images/image-20210128183636938.png" src="../_images/image-20210128183636938.png" /></p>
</center><p>The length of a path in a weighted graph is the sum of the edge weights on the path. For example, in the above graph, the length of the path 1 → 2 → 5 is 12, and the length of the path 1→3→4→5 is 11. The latter path is the <strong>shortest</strong> path from node 1 to node 5.</p>
</div>
<div class="section" id="neighbors-and-degrees">
<h3><span class="section-number">17.1.4. </span>Neighbors and degrees相邻的两个顶点和顶点的度<a class="headerlink" href="#neighbors-and-degrees" title="Permalink to this headline">¶</a></h3>
<p>Two nodes are <strong>neighbors</strong> or <strong>adjacent</strong> if there is an edge between them. The <strong>degree</strong> of a node is the number of its neighbors. For example, in the following graph, the neighbors of node 2 are 1, 4 and 5, so its degree is 3.</p>
<center><p><img alt="../_images/image-20210128183754769.png" src="../_images/image-20210128183754769.png" /></p>
</center><p>The sum of degrees in a graph is always 2<em>m</em>, where <em>m</em> is the number of edges, because each edge increases the degree of exactly two nodes by one. For this reason, the sum of degrees is always even.</p>
<p>A graph is <strong>regular</strong> if the degree of every node is a constant <em>d</em>. A graph is <strong>complete</strong> if the degree of every node is <em>n</em> − 1, i.e., the graph contains all possible edges between the nodes.</p>
<p>In a directed graph, the <strong>indegree</strong> of a node is the number of edges that end at the node, and the <strong>outdegree</strong> of a node is the number of edges that start at the node. For example, in the following graph, the indegree of node 2 is 2, and the outdegree of node 2 is 1.</p>
<center><p><img alt="../_images/image-20210128183824451.png" src="../_images/image-20210128183824451.png" /></p>
</center><p>概念：完全图，每个顶点的度数都是n-1。在有向图中，分为入度和出度。</p>
</div>
<div class="section" id="simplicity">
<h3><span class="section-number">17.1.5. </span>Simplicity简单图<a class="headerlink" href="#simplicity" title="Permalink to this headline">¶</a></h3>
<p>A graph is <strong>simple</strong> if no edge starts and ends at the same node, and there are no multiple edges between two nodes. Often we assume that graphs are simple. For example, the following graph is <em>not</em> simple:</p>
<center><p><img alt="../_images/image-20210128184003302.png" src="../_images/image-20210128184003302.png" /></p>
</center><p>概念：简单图，无重边，无自环</p>
</div>
</div>
<div class="section" id="graph-representation">
<h2><span class="section-number">17.2. </span>Graph representation建图<a class="headerlink" href="#graph-representation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="adjacency-list-representation-vector">
<h3><span class="section-number">17.2.1. </span>Adjacency list representation邻接表建图(vector版本)<a class="headerlink" href="#adjacency-list-representation-vector" title="Permalink to this headline">¶</a></h3>
<p>In the adjacency list representation, each node <em>x</em> in the graph is assigned an <strong>adjacency list</strong> that consists of nodes to which there is an edge from <em>x</em>. Adjacency lists are the most popular way to represent graphs, and most algorithms can be efficiently implemented using them.</p>
<p>A convenient way to store the adjacency lists is to declare an array of vectors as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</pre></div>
</div>
<p>The constant <em>N</em> is chosen so that all adjacency lists can be stored. For example, the graph</p>
<center><p><img alt="../_images/image-20210128184136255.png" src="../_images/image-20210128184136255.png" /></p>
</center><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">adj</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">adj</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">adj</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">adj</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">adj</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>If the graph is undirected, it can be stored in a similar way, but each edge is added in both directions.</p>
<p>For a weighted graph, the structure can be extended as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//当边权不是1的时候，可以用pair维护</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</pre></div>
</div>
<p>In this case, the adjacency list of node <em>a</em> contains the pair (<em>b</em>,<em>w</em>) always when there is an edge from node <em>a</em> to node <em>b</em> with weight <em>w</em>. For example, the graph can be stored as follows:</p>
<center><p><img alt="../_images/image-20210128184252453.png" src="../_images/image-20210128184252453.png" /></p>
</center><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">adj</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">});</span>
<span class="n">adj</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">});</span>
<span class="n">adj</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">});</span>
<span class="n">adj</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">});</span>
<span class="n">adj</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">});</span>
</pre></div>
</div>
<p>The benefit of using adjacency lists is that we can efficiently find the nodes to which we can move from a given node through an edge. For example, the following loop goes through all nodes to which we can move from node <em>s</em>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//这是C++ 11的写法，在比赛中，还不能使用</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">u</span> <span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="p">{</span>
    <span class="c1">// process node u</span>
<span class="p">}</span>

<span class="c1">//这样枚举就可以了，理解“散列边”这个概念</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="adjacency-matrix-representation">
<h3><span class="section-number">17.2.2. </span>Adjacency matrix representation邻接矩阵建图<a class="headerlink" href="#adjacency-matrix-representation" title="Permalink to this headline">¶</a></h3>
<p>An <strong>adjacency matrix</strong> is a two-dimensional array that indicates which edges the graph contains. We can efficiently check from an adjacency matrix if there is an edge between two nodes. The matrix can be stored as an array</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">adj</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
</pre></div>
</div>
<p>where each value adj[<em>a</em>][<em>b</em>] indicates whether the graph contains an edge from node <em>a</em> to node <em>b</em>. If the edge is included in the graph, then adj[<em>a</em>][<em>b</em>] = 1, and otherwise adj[<em>a</em>][<em>b</em>] = 0. For example, the graph can be represented as follows:</p>
<center><p><img alt="../_images/image-20210128184524164.png" src="../_images/image-20210128184524164.png" /></p>
<p><img alt="../_images/image-20210128184546508.png" src="../_images/image-20210128184546508.png" /></p>
</center><p>If the graph is weighted, the adjacency matrix representation can be extended so that the matrix contains the weight of the edge if the edge exists. Using this representation, the graph corresponds to the following matrix:</p>
<center><p><img alt="../_images/image-20210128184620255.png" src="../_images/image-20210128184620255.png" /></p>
<p><img alt="../_images/image-20210128184632710.png" src="../_images/image-20210128184632710.png" /></p>
</center><p>The drawback of the adjacency matrix representation is that the matrix contains <strong>n^2</strong> elements, and usually most of them are zero. For this reason, the representation cannot be used if the graph is large.</p>
<center><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>你看，这个邻接矩阵是不是就是一个矩阵，表示一个点和另外一个点的连通性
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>邻接矩阵不能存很大的图，因为受建立二维数组大小的限制。适合存稠密图
邻接表可以存很大的图，也可以存很小的图。更适合存稀疏图
</pre></div>
</div>
</center></div>
<div class="section" id="adjacency-list-representation">
<h3><span class="section-number">17.2.3. </span>Adjacency list representation邻接表建图(一维数组版本)<a class="headerlink" href="#adjacency-list-representation" title="Permalink to this headline">¶</a></h3>
<p>我一般用这个方法</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">h</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="n">M</span><span class="p">],</span> <span class="n">ne</span><span class="p">[</span><span class="n">M</span><span class="p">],</span> <span class="n">idx</span><span class="p">;</span> 

<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">e</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">ne</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//调用</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
<span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="c1">//双向表，就双向add，单向边就一个add</span>
<span class="c1">//要注意一维数组开的大小问题，如果是无向图，M是N的两倍</span>
<span class="c1">//如果是有边权的情况，就还需要开一个一维数组w[M]用来维护边权</span>
<span class="c1">//理解“散列”的形状</span>

<span class="c1">//枚举边</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ne</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="c1">//所有子树的最大值</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">s</span><span class="p">;</span>          <span class="c1">//累积求这个点的子树大小</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="graph-traversal">
<h2><span class="section-number">17.3. </span>Graph traversal图的遍历<a class="headerlink" href="#graph-traversal" title="Permalink to this headline">¶</a></h2>
<p>depth-first search and breadth-first search. Both algorithms are given a starting node in the graph, and they visit all nodes that can be reached from the starting node. The difference in the algorithms is the order in which they visit the nodes.</p>
<div class="section" id="depth-first-search">
<h3><span class="section-number">17.3.1. </span>Depth-first search深度优先遍历<a class="headerlink" href="#depth-first-search" title="Permalink to this headline">¶</a></h3>
<p>Depth-first search always follows a single path in the graph as long as it finds new nodes. After this, it returns to previous nodes and begins to explore other parts of the graph. The algorithm keeps track of visited nodes, so that it processes each node only once.</p>
<center><p><img alt="../_images/image-20210204135134206.png" src="../_images/image-20210204135134206.png" /></p>
</center><p>The neighbors of node 5 are 2 and 3, but the search has already visited both of them, so it is time to return to the previous nodes. Also the neighbors of nodes 3 and 2 have been visited, so we next move from node 1 to node 4</p>
<p>The time complexity of depth-first search is <strong><em>O</em>(<em>n</em> + <em>m</em>)</strong> where <em>n</em> is the number of nodes and <em>m</em> is the number of edges, because the algorithm processes each node and edge once.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="c1">// process node s</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">u</span><span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="breadth-first-search">
<h3><span class="section-number">17.3.2. </span>Breadth-first search宽度优先遍历<a class="headerlink" href="#breadth-first-search" title="Permalink to this headline">¶</a></h3>
<p><strong>Breadth-first search</strong> (BFS) visits the nodes in increasing order of their distance from the starting node. Thus, we can calculate the distance from the starting node to all other nodes using breadth-first search.</p>
<center><p><img alt="../_images/image-20210204135619766.png" src="../_images/image-20210204135619766.png" /></p>
</center><p>Like in depth-first search, the time complexity of breadth-first search is <strong><em>O</em>(<em>n</em> + <em>m</em>)</strong>, where <em>n</em> is the number of nodes and <em>m</em> is the number of edges.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">distance</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">distance</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="c1">// process node s</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">u</span> <span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="p">{</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
       <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
       <span class="n">distance</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
       <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
	<span class="p">}</span> 
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Connectivity check图的连通性验证(应用)</strong></p>
<p>从任意一个点出发，做dfs，可以判断这个图是否连通的。通过这种方法，我们也可以用来统计图当中，有多少个独立的块。从1…n遍历，如果一个点没遍历过，就dfs进去，遍历的时候进行标记。</p>
<p>A graph is connected if there is a path between any two nodes of the graph. Thus, we can check if a graph is connected by starting at an arbitrary node and finding out if we can reach all other nodes. For example, in the graph a depth-first search from node 1 visits the following nodes:</p>
<center><p><img alt="../_images/image-20210216142822489.png" src="../_images/image-20210216142822489.png" /></p>
</center><p>Since the search did not visit all the nodes, we can conclude that the graph is not connected. In a similar way, we can also find all connected components of a graph by iterating through the nodes and always starting a new depth-first search if the current node does not belong to any component yet.</p>
<p><strong>Finding cycles判环(应用)</strong></p>
<p>A graph contains a cycle if during a graph traversal, we find a node whose neighbor (other than the previous node in the current path) has already been visited. For example, the graph contains two cycles and we can find one of them as follows:</p>
<p><img alt="../_images/image-20210216143233356.png" src="../_images/image-20210216143233356.png" /></p>
<p>After moving from node 2 to node 5 we notice that the neighbor 3 of node 5 has already been visited. Thus, the graph contains a cycle that goes through node 3, for example, 3→2→5→3.</p>
<p>Another way to find out whether a graph contains a cycle is to simply calculate the number of nodes and edges in every component. If a component contains <em>c</em> nodes and no cycle, it must contain exactly <em>c</em> − 1 edges (so it has to be a tree). If there are <em>c</em> or more edges, the component surely contains a cycle.（如果边数&gt;=c，那么一定存在环）</p>
</div>
</div>
<div class="section" id="id1">
<h2><span class="section-number">17.4. </span>《一本通》题目<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id2">
<h3><span class="section-number">17.4.1. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1341">【例题】一笔画问题</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//寻找欧拉路/欧拉回路。</span>
<span class="c1">//找到入度是奇数的点，这个点作为出发点。否则就从1开始出发</span>
<span class="c1">//dfs()遍历图，一边走一遍划掉边</span>
</pre></div>
</div>
</div>
<div class="section" id="snow">
<h3><span class="section-number">17.4.2. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1374">铲雪车(snow)</a><a class="headerlink" href="#snow" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//每条道路都是双向道路，题面说明可以遍历所有街道，那一定是欧拉回路的</span>
<span class="c1">//直接利用欧拉回路的性质解题</span>
<span class="c1">//需要注意的是时间有可能很大，不开LL见祖宗</span>
</pre></div>
</div>
</div>
<div class="section" id="fence">
<h3><span class="section-number">17.4.3. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1375">骑马修栅栏(fence)</a><a class="headerlink" href="#fence" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//一笔画问题，一笔遍历完所有栅栏</span>
<span class="c1">//完成建图后，从度数是奇数的点出发，进行dfs()，一边走一边抹掉边</span>
<span class="c1">//题目中没有给出结点编号范围，在读入的时候，明确一下起始和终止结点编号</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3><span class="section-number">17.4.4. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1342">【例4-1】最短路径问题</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//n&lt;=100</span>
<span class="c1">//朴素dijkstra</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3><span class="section-number">17.4.5. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1343"> 【例4-2】牛的旅行</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//n&lt;=150</span>
<span class="c1">//编程找出一条连接两个不同牧场的路径，使得连上这条路径后，这个更大的新牧场有最小的直径</span>

<span class="c1">//floyd预处理两点之间的最短距离</span>
<span class="c1">//用来判断两个点是否在一个连通块内</span>
<span class="c1">//先更新一遍连通块内部的最大直径，维护一个s1[N]</span>
<span class="c1">//res1，代表连通块的最大直径</span>
<span class="c1">//再暴力枚举，连接两个不连通的两个点，更新一个连上之后半径</span>
<span class="c1">//res2，代表连上两个连通块之后的半径</span>
<span class="c1">//问：使得连上这条路径后，这个更大的新牧场有最小的直径</span>
<span class="c1">//输出min(res1, res2)</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3><span class="section-number">17.4.6. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1344">【例4-4】最小花费</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//n&lt;=2000</span>
<span class="c1">//转账需要扣除手续费，问终点的人收到100元，起点的人，最少需要准备多少钱</span>
<span class="c1">//最短路问题</span>
<span class="c1">//如果边长是1.0 * (100 - c) / 100, c代表扣除的手续费</span>
<span class="c1">//那么就是用朴素dijkstra跑一遍最长路</span>
</pre></div>
</div>
<div class="section" id="id6">
<h4><span class="section-number">17.4.6.1. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1345">【例4-6】香甜的黄油</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//找出使所有牛到达的路程和最短的牧场（他将把糖放在那）</span>
<span class="c1">//奶牛n&lt;=500,牧场p&lt;=800</span>
<span class="c1">//枚举所有的牧场，跑最短路，更新res</span>
<span class="c1">//可以用spfa，堆优化dijkstra</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="msner">
<h3><span class="section-number">17.4.7. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1376">信使(msner)</a><a class="headerlink" href="#msner" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//n&lt;=100</span>
<span class="c1">//所有结点到结点1距离的最小值</span>
<span class="c1">//跑一遍floyd，找一遍答案，如果发现有无法到达的结点就输出-1</span>
</pre></div>
</div>
</div>
<div class="section" id="travel">
<h3><span class="section-number">17.4.8. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1377">最优乘车(travel)</a><a class="headerlink" href="#travel" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//n&lt;=500</span>
<span class="c1">//这道题思路比较巧妙，第一反应是分层图，很快就验证不对</span>
<span class="c1">//正确思路：一条公交路线上的结点(注意是单向)，这些结点的距离都是1</span>
<span class="c1">//那么从起点，到终点的最短路，减去1，就是答案</span>
<span class="c1">//最短路可用floyd</span>

<span class="c1">//恶心的是输入，不好处理</span>
<span class="c1">//方法一：还要注意把第一行的回车处理好</span>
	<span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="n">stringstream</span> <span class="nf">ssin</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ssin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="c1">//方法二：</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]);</span>
	<span class="n">ch</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ch</span><span class="o">==</span><span class="sc">&#39; &#39;</span><span class="p">){</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
		<span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">ch</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
	<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="shopth">
<h3><span class="section-number">17.4.9. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1378">最短路径(shopth)</a><a class="headerlink" href="#shopth" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//n&lt;=80，题意也是明显的floyd最短路</span>
<span class="c1">//恶心的还是读入</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="p">}</span>
<span class="c1">//这种方法在本地无法通过验证</span>
<span class="c1">//提交oj可以AC</span>
<span class="c1">//尝试getline() 然后处理&#39;-&#39; &#39;负数&#39; &#39;正数&#39;的方法，只能过40分，作罢</span>
</pre></div>
</div>
</div>
<div class="section" id="heatwv">
<h3><span class="section-number">17.4.10. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1379">热浪(heatwv)</a><a class="headerlink" href="#heatwv" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//T&lt;=2500</span>
<span class="c1">//跑spfa</span>
</pre></div>
</div>
</div>
<div class="section" id="candy">
<h3><span class="section-number">17.4.11. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1380">分糖果(candy)</a><a class="headerlink" href="#candy" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//求第多少秒所有小朋友都吃完了糖</span>
<span class="c1">//spfa求得距离C小朋友最远的距离far</span>
<span class="c1">//答案是far + 1 + m</span>
<span class="c1">//传到最远位置的时间，第一个人消耗的时间，最后一个人吃的时间</span>
</pre></div>
</div>
</div>
<div class="section" id="dijkstra">
<h3><span class="section-number">17.4.12. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1381"> 城市路(Dijkstra)</a><a class="headerlink" href="#dijkstra" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//n&lt;=2000</span>
<span class="c1">//朴素dijkstra</span>
<span class="c1">//bellman_ford也可以</span>
</pre></div>
</div>
</div>
<div class="section" id="spfa">
<h3><span class="section-number">17.4.13. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1382">最短路(Spfa)</a><a class="headerlink" href="#spfa" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//n&lt;=1e5</span>
<span class="c1">//有重边、自环，跑spfa求最短路</span>
<span class="c1">//读入的时候，可以不理会重边和自环问题</span>
</pre></div>
</div>
</div>
<div class="section" id="spfa-ii">
<h3><span class="section-number">17.4.14. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1419"> SPFA(II)</a><a class="headerlink" href="#spfa-ii" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//n&lt;=20000</span>
<span class="c1">//spfa</span>
</pre></div>
</div>
</div>
<div class="section" id="dijkastra-ii">
<h3><span class="section-number">17.4.15. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1420">Dijkastra(II)</a><a class="headerlink" href="#dijkastra-ii" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//n&lt;=2e5</span>
<span class="c1">//堆优化dijkstra</span>
</pre></div>
</div>
</div>
<div class="section" id="floyd">
<h3><span class="section-number">17.4.16. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1421"> Floyd</a><a class="headerlink" href="#floyd" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//n&lt;=500, floyd</span>
<span class="c1">//题目不存在负环，但是可能存在负边</span>
<span class="c1">//这样会造成dist &lt; INF 但是也是不可达</span>
<span class="c1">//最后计算结果前，对不可达的点，刷一遍，刷成INF</span>
</pre></div>
</div>
</div>
<div class="section" id="cdrom">
<h3><span class="section-number">17.4.17. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1383">刻录光盘(cdrom)</a><a class="headerlink" href="#cdrom" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//图的连通性问题</span>
<span class="c1">//利用floyd，判断出两个点是否可达</span>
<span class="c1">//two loops枚举所有两个点组合，用并查集p[i]来更新父亲</span>
<span class="c1">//最后one loops遍历一遍有几个结点的p[i]==i,就说明需要几个光盘</span>
</pre></div>
</div>
</div>
<div class="section" id="bead">
<h3><span class="section-number">17.4.18. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1384">珍珠(bead)</a><a class="headerlink" href="#bead" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//读入的时候，dp[a][b]=1，表示a比b大</span>
<span class="c1">//跑floyd，得到所有两两关系</span>
<span class="c1">//two loops枚举两点，统计对于每个点，有多少个点比自己大，有多少个点比自己小</span>
<span class="k">if</span> <span class="p">((</span><span class="n">cnt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">cnt2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="n">res</span><span class="o">++</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="relation">
<h3><span class="section-number">17.4.19. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1346">【例4-7】亲戚(relation)</a><a class="headerlink" href="#relation" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//并查集</span>
<span class="c1">//只能通过90分，网上的题解也不能AC</span>
<span class="c1">//网站上还是有2500多人AC的【待办】</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3><span class="section-number">17.4.20. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1347">【例4-8】格子游戏</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//并查集</span>
<span class="c1">//二维转一维的操作(x = (a - 1) * n + b;)</span>
<span class="c1">//两个点是否在一个集合里，如何在，那么连上就成圈了</span>
<span class="c1">//整个看成一个图，容易理解</span>
</pre></div>
</div>
</div>
<div class="section" id="group">
<h3><span class="section-number">17.4.21. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1385">团伙(group)</a><a class="headerlink" href="#group" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//并查集</span>
<span class="c1">//1、我朋友的朋友是我的朋友；2、我敌人的敌人是我的朋友；</span>
<span class="c1">//使用vector&lt;int&gt; h[N]存储每个点的所有敌人，类似开放链</span>
<span class="c1">//当读到两个人是敌人，就枚举一遍已有的敌人，敌人的敌人是朋友，建立起朋友关系</span>
<span class="c1">//最后看p[N]中有几个祖宗，可以用set&lt;int&gt;进行统计</span>
</pre></div>
</div>
</div>
<div class="section" id="black">
<h3><span class="section-number">17.4.22. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1386">打击犯罪(black)</a><a class="headerlink" href="#black" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//并查集</span>
<span class="c1">//p[N]维护祖先，son[N]维护子树大小</span>
<span class="c1">//所有有关系的团队，都是编号大的向编号小的合并，合并的时候，更新子树大小</span>
<span class="c1">//最后把son[k]&gt;n/2的干掉，1...k都干掉（从n往1遍历找到一个满足条件的i就是答案）</span>
</pre></div>
</div>
</div>
<div class="section" id="buy">
<h3><span class="section-number">17.4.23. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1387">搭配购买(buy)</a><a class="headerlink" href="#buy" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//并查集+01背包（题意不是只可以买一个集合的，可以买多个集合的，要考虑到这些）</span>
<span class="c1">//并查集维护出来每一个集合的体积和，价值和</span>
<span class="c1">//然后对这些体积和，价值和，进行01背包，求max</span>
</pre></div>
</div>
</div>
<div class="section" id="gen">
<h3><span class="section-number">17.4.24. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1388">家谱(gen)</a><a class="headerlink" href="#gen" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//并查集</span>
<span class="c1">//用map&lt;string, string&gt; p;维护祖先关系</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3><span class="section-number">17.4.25. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1389">亲戚</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//并查集</span>
<span class="c1">//p[N]维护祖先, son[N]维护子树大小</span>
</pre></div>
</div>
</div>
<div class="section" id="noi2001">
<h3><span class="section-number">17.4.26. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1390">食物链【NOI2001】</a><a class="headerlink" href="#noi2001" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A</span>
<span class="c1">//此题精华：知道每个点和根结点的关系,就能知道每个点之间的关系</span>
<span class="c1">//到根结点距离是1，可以吃根</span>
<span class="c1">//到根结点距离是2，可以被根吃</span>
<span class="c1">//到根结点距离是3，与根同类</span>

<span class="c1">//在一个组织里，求两人之间的距离，只需要知道和领袖之间的距离</span>
<span class="c1">//d[x],d[y]的差值，看mod 3的值，来分析吃与被吃的关系</span>

<span class="c1">//部分示例代码</span>
<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">px</span> <span class="o">==</span> <span class="n">py</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">y</span><span class="p">])</span><span class="o">%</span><span class="mi">3</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="n">res</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">px</span> <span class="o">!=</span> <span class="n">py</span><span class="p">){</span>		
        <span class="n">p</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">=</span> <span class="n">py</span><span class="p">;</span>
		<span class="n">d</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
		<span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]];</span>  <span class="c1">//递归的加上每一个前辈的距离，就是到祖先的距离</span>
		<span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3><span class="section-number">17.4.27. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1348"> 【例4-9】城市公交网建设问题</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//n&lt;=100, MST</span>
<span class="c1">//kruscal，取边的时候，维护到答案里</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3><span class="section-number">17.4.28. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1349">【例4-10】最优布线问题</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//n&lt;=100, MST</span>
<span class="c1">//prim</span>
</pre></div>
</div>
</div>
<div class="section" id="agrinet">
<h3><span class="section-number">17.4.29. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1350">【例4-11】最短网络(agrinet)</a><a class="headerlink" href="#agrinet" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//n&lt;=100, MST</span>
<span class="c1">//prim</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h3><span class="section-number">17.4.30. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1351">【例4-12】家谱树</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//topsort</span>
</pre></div>
</div>
</div>
<div class="section" id="net">
<h3><span class="section-number">17.4.31. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1391">局域网(net)</a><a class="headerlink" href="#net" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//n&lt;=100, MST</span>
<span class="c1">//prim</span>
</pre></div>
</div>
</div>
<div class="section" id="city">
<h3><span class="section-number">17.4.32. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1392">繁忙的都市(city)</a><a class="headerlink" href="#city" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//边长进行排序(greedy)，做并查集</span>
<span class="c1">//维护选出了几条道路，分值最大的那条道路的分值</span>
</pre></div>
</div>
</div>
<div class="section" id="liaison">
<h3><span class="section-number">17.4.33. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1393">联络员(liaison)</a><a class="headerlink" href="#liaison" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//通讯渠道分为两类，一类必选，一类选择性选择</span>
<span class="c1">//必选都选上，维护res，维护并查集关系</span>
<span class="c1">//然后选择性边排序(greedy)，做并查集</span>
</pre></div>
</div>
</div>
<div class="section" id="grid">
<h3><span class="section-number">17.4.34. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1394"> 连接格点(grid)</a><a class="headerlink" href="#grid" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//二维转一维的操作</span>
<span class="c1">//优先对纵向(花费1)做并查集，然后对横向(花费2)做并查集</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3><span class="section-number">17.4.35. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1352">【例4-13】奖金</a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//满足各位代表的意见，且同时使得总奖金数最少</span>
<span class="c1">//反向建边，add(b, a); in[a]++, 进行topsort</span>
<span class="c1">//反向处理的时候，后一结点比前一结点花费多1(员工a的奖金应该比b高)</span>
</pre></div>
</div>
</div>
<div class="section" id="slides">
<h3><span class="section-number">17.4.36. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1395">烦人的幻灯片(slides)</a><a class="headerlink" href="#slides" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//幻灯片用字母表示</span>
<span class="c1">//每个数字的位置读入后，判断都在哪些字母范围内</span>
<span class="c1">//建边g[j][i] = 1; //字母j到数字i有边，同时，维护好in[i]，数字的度数</span>
<span class="c1">//这样就形成了一个两个集合的映射关系，从数字度数为1的，进行topsort</span>
<span class="c1">//topsort(u)，查找和数字u有关系的字母i，紧接着看那些数字j和字母i有关系</span>
<span class="c1">//把边抹掉，in[j]--。如果in[j]==1，topsort(j)</span>
</pre></div>
</div>
</div>
<div class="section" id="virus">
<h3><span class="section-number">17.4.37. </span><a class="reference external" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1396"> 病毒(virus)</a><a class="headerlink" href="#virus" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//病毒污染了字典，把字母换成了另外一个字母，但是相对顺序没有改变</span>
<span class="c1">//给了多个字符串，读入后，维护起来污染后字母的相对顺序，然后做topsort</span>
<span class="c1">//做topsort的时候，维护好d[i]，存的是原字母相对于a的偏移</span>
<span class="c1">//遍历一遍d[i]，维护map&lt;char, char&gt;</span>
<span class="c1">//对要翻译的字符串进行处理，如果遇到没有翻译的字符，就是字典不全</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="%E5%9B%BE%E8%AE%BA%E4%BA%8C.html" class="btn btn-neutral float-right" title="18. graph图论(二)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="%E9%98%9F%E5%88%97.html" class="btn btn-neutral float-left" title="16. queue队列" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, zqiceberg.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>