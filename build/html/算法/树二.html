

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>21. trees树(二) &mdash; 信息学奥赛普及组算法21天突破 0.7.1 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="1. 517教学经验" href="../%E7%BB%8F%E9%AA%8C/517.html" />
    <link rel="prev" title="20. trees树(一)" href="%E6%A0%91%E4%B8%80.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> 信息学奥赛普及组算法21天突破
          

          
          </a>

          
            
            
              <div class="version">
                0.7.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">一、普及组算法部分</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="%E5%BA%8F%E8%A8%80.html">1. preface序言</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html">2. time complexity时间复杂度</a></li>
<li class="toctree-l1"><a class="reference internal" href="STL.html">3. data structure(STL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%AB%98%E7%B2%BE%E5%BA%A6.html">4. high accuracy高精度</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%8E%92%E5%BA%8F.html">5. sortings排序</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%80%92%E6%8E%A8.html">6. recursion 递推</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%80%92%E5%BD%92.html">7. recursive 递归</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF.html">8. complete search and backtracking 搜索与回溯</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E8%B4%AA%E5%BF%83%E4%B8%80.html">9. greedy algorithm 贪心(一)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E8%B4%AA%E5%BF%83%E4%BA%8C.html">10. greedy algorithm 贪心(二)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%88%86%E6%B2%BB.html">11. divide and conquer分治</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.html">12. bfs宽度优先搜索</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80.html">13. DP动态规划(一)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BA%8C.html">14. DP动态规划(二)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%A0%88.html">15. stack栈</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E9%98%9F%E5%88%97.html">16. queue队列</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%9B%BE%E8%AE%BA%E4%B8%80.html">17. graph图论(一)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%9B%BE%E8%AE%BA%E4%BA%8C.html">18. graph图论(二)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%9B%BE%E8%AE%BA%E4%B8%89.html">19. graph图论(三)</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%A0%91%E4%B8%80.html">20. trees树(一)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">21. trees树(二)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#finding-ancestors">21.1. Finding ancestors(查找祖先)(倍增)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#subtrees-and-paths">21.2. Subtrees and paths</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#subtree-queries">21.2.1. <strong>Subtree queries</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="#path-queries">21.2.2. <strong>Path queries</strong></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#lowest-common-ancestorlca">21.3. Lowest common ancestor最近公共祖先LCA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">21.3.1. #方法一 向上标记法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">21.3.2. #方法二 树上倍增法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#euler-tour-technique">21.3.3. #方法三 Euler tour technique欧拉序列</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tarjan">21.3.4. #方法四 Tarjan算法</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">二、计算机使用教程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/517.html">1. 517教学经验</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Focused%20vs%20Diffused%20Thinking%3A%20Solve%20Hard%20Problems%20with%20this%20Simply%20Trick.html">2. Focused vs Diffused Thinking: Solve Hard Problems with this Simply Trick</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/NOI%E5%A4%A7%E7%BA%B2.html">3. NOI大纲</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Tackling%20a%20problem%20.html">4. Tackling a problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Thinking%20-%20Brainsotrm%20-%20Rank%20-%20Approach%20.html">5. Thinking - Brainsotrm - Rank - Approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Thinking%20-%20Concretely%2C%20Symbolically%2C%20Pictorially.html">6. Thinking - Concretely, Symbolically, Pictorially</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Thinking%20-%20Problem%20Simplification.html">7. Thinking - Problem Simplification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C.html">8. Windows环境下的操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/macOS%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C.html">9. macOS环境下的操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E4%B8%AD%E5%AD%A6%E8%B6%85%E5%89%8D%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%8E%86%E5%AF%B9%E5%A4%A7%E5%AD%A6%E6%8B%94%E5%B0%96%E5%AD%A6%E7%94%9F%E5%AD%A6%E4%B9%A0%E7%8A%B6%E6%80%81%E7%9A%84%E5%BD%B1%E5%93%8D.html">10. 中学超前学习经历对大学拔尖学生学习状态的影响</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E4%BB%A3%E7%A0%81%E7%BB%8F%E9%AA%8C.html">11. 代码经验</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E4%BF%A1%E6%81%AF%E5%AD%A6%E6%AF%94%E8%B5%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html">12. 信息学比赛常见问题</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E5%85%B3%E4%BA%8E%E6%AF%8F%E5%A4%A9%E6%89%93%E5%8D%A1%E7%9A%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%BC%8F.html">13. 关于每天打卡的训练模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E5%8C%97%E5%A4%A7%E6%9D%8E%E6%99%93%E6%98%8E%E6%95%99%E6%8E%88%EF%BC%9A%E4%BB%8E%E8%B6%A3%E5%91%B3%E6%95%B0%E5%AD%A6%E5%88%B0%E8%B6%A3%E5%91%B3%E7%AE%97%E6%B3%95%E5%88%B0%E8%B6%A3%E5%91%B3%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E9%9D%9E%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0%E8%80%85%E4%BD%93%E4%BC%9A%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E7%9A%84%E4%B8%80%E6%9D%A1%E9%80%94%E5%BE%84%EF%BC%9F.html">14. 北大李晓明教授：从趣味数学到趣味算法到趣味编程——非专业学习者体会计算思维的一条途径？</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E7%BB%8F%E9%AA%8C/%E5%AF%B9%E8%AF%9DIOI2021%E5%9B%BD%E5%AE%B6%E9%98%9F%E6%88%90%E5%91%98%EF%BC%81%E7%9B%B4%E6%92%AD%E8%B6%85%E8%AF%A6%E7%BB%86%E6%96%87%E5%AD%97%E7%8F%8D%E8%97%8F%E7%89%88%E6%9D%A5%E5%95%A6.html">15. 对话IOI2021国家队成员！直播超详细文字珍藏版来啦</a></li>
</ul>
<p class="caption"><span class="caption-text">三、C++语言部分</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/endl.html">1. end and flushing the buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/int%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E6%98%AF-2%5E31~2%5E31-1.html">2. int型数据类型为什么取值范围是-2^31~2^31-1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E4%B8%80%E3%80%81C%2B%2B%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8.html">3. C++语言入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E4%B8%89%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html">4. 控制结构程序设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html">5. 顺序结构程序设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E4%BA%94%E3%80%81%E6%95%B0%E7%BB%84.html">6. 数组</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E5%85%AD%E3%80%81%E5%87%BD%E6%95%B0.html">7. 函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E5%9B%9B%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html">8. 循环结构程序设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E8%AF%AD%E6%B3%95/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html">9. 输入输出</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">信息学奥赛普及组算法21天突破</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">21. </span>trees树(二)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/算法/树二.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="trees">
<h1><span class="section-number">21. </span>trees树(二)<a class="headerlink" href="#trees" title="Permalink to this headline">¶</a></h1>
<p><strong>Tree queries</strong>这部分属于提高组内容，但很值得了解了解。</p>
<ul class="simple">
<li><p>what is the <em>k</em>th ancestor of a node？</p></li>
<li><p>what is the sum of values in the subtree of a node?</p></li>
<li><p>what is the sum of values on a path between two nodes?</p></li>
<li><p>what is the lowest common ancestor of two nodes?</p></li>
</ul>
<div class="section" id="finding-ancestors">
<h2><span class="section-number">21.1. </span>Finding ancestors(查找祖先)(倍增)<a class="headerlink" href="#finding-ancestors" title="Permalink to this headline">¶</a></h2>
<p>The <em>k</em>th <strong>ancestor</strong> of a node <em>x</em> in a rooted tree is the node that we will reach if we move <em>k</em> levels up from <em>x</em>. Let ancestor(<em>x</em>,<em>k</em>) denote the <em>k</em>th ancestor of a node <em>x</em> (or 0 if there is no such an ancestor). For example, in the following tree, ancestor(2, 1) = 1 and ancestor(8, 2) = 4.</p>
<p><img alt="../_images/image-20210216152628069.png" src="../_images/image-20210216152628069.png" /></p>
<p>An easy way to calculate any value of ancestor(<em>x</em>,<em>k</em>) is to perform a sequence of <em>k</em> moves in the tree. However, the time complexity of this method is <strong><em>O</em>(<em>k</em>)</strong>, which may be slow, because a tree of <em>n</em> nodes may have a chain of <em>n</em> nodes.</p>
<p>any value of ancestor(<em>x</em>, <em>k</em>) can be efficiently calculated in <em>O</em>(log <em>k</em>) time after preprocessing. The idea is to precalculate all values ancestor(<em>x</em>, <em>k</em>) where <em>k</em> ≤ <em>n</em> is a power of two. For example, the values for the above tree are as follows:(<strong>倍增</strong>，类似<strong>Successor paths</strong>)</p>
<p><img alt="../_images/image-20210216152811133.png" src="../_images/image-20210216152811133.png" /></p>
<p>The preprocessing takes <strong><em>O</em>(<em>n</em> log <em>n</em>)</strong> time, because **<em>O</em>(log <em>n</em>) **values are calculated for each node. After this, any value of ancestor(<em>x</em>,<em>k</em>) can be calculated in <em><em><em>O</em>(log</em>k</em>) **time by representing <em><strong>k</strong></em> as a sum where each term is a power of two.</p>
</div>
<div class="section" id="subtrees-and-paths">
<h2><span class="section-number">21.2. </span>Subtrees and paths<a class="headerlink" href="#subtrees-and-paths" title="Permalink to this headline">¶</a></h2>
<p>A <strong>tree traversal array</strong> contains the nodes of a rooted tree in the order in which a depth-first search from the root node visits them.</p>
<p><img alt="../_images/image-20210216155716167.png" src="../_images/image-20210216155716167.png" /></p>
<p><img alt="../_images/image-20210216155741218.png" src="../_images/image-20210216155741218.png" /></p>
<p>Hence, the corresponding tree traversal array is as follows:</p>
<p><img alt="../_images/image-20210216155759995.png" src="../_images/image-20210216155759995.png" /></p>
<div class="section" id="subtree-queries">
<h3><span class="section-number">21.2.1. </span><strong>Subtree queries</strong><a class="headerlink" href="#subtree-queries" title="Permalink to this headline">¶</a></h3>
<p>Each subtree of a tree corresponds to a subarray of the tree traversal array such that the first element of the subarray is the root node. For example, the following subarray contains the nodes of the subtree of node 4:</p>
<p><img alt="../_images/image-20210216160200252.png" src="../_images/image-20210216160200252.png" /></p>
<p>Using this fact, we can efficiently process queries that are related to subtrees of a tree. As an example, consider a problem where each node is assigned a value, and our task is to support the following queries:</p>
<ul class="simple">
<li><p>update the value of a node</p></li>
<li><p>calculate the sum of values in the subtree of a node</p></li>
</ul>
<p>Consider the following tree where the blue numbers are the values of the nodes. For example, the sum of the subtree of node 4 is 3+4+3+1=11.</p>
<p><img alt="../_images/image-20210216160314293.png" src="../_images/image-20210216160314293.png" /></p>
<p>The idea is to construct a tree traversal array that contains three values for each node: the identifier of the node, the size of the subtree, and the value of the node. For example, the array for the above tree is as follows:</p>
<p><img alt="../_images/image-20210216160337743.png" src="../_images/image-20210216160337743.png" /></p>
<p>Using this array, we can calculate the sum of values in any subtree by first finding out the size of the subtree and then the values of the corresponding nodes. For example, the values in the subtree of node 4 can be found as follows:</p>
<p><img alt="../_images/image-20210216161349159.png" src="../_images/image-20210216161349159.png" /></p>
<p>To answer the queries efficiently, it suffices to store the values of the nodes in a <strong>binary indexed or segment tree</strong>. After this, we can both update a value and calculate the sum of values in <strong><em>O</em>(log <em>n</em>)</strong> time.</p>
</div>
<div class="section" id="path-queries">
<h3><span class="section-number">21.2.2. </span><strong>Path queries</strong><a class="headerlink" href="#path-queries" title="Permalink to this headline">¶</a></h3>
<p>Using a tree traversal array, we can also efficiently calculate sums of values on paths from the root node to any node of the tree. Consider a problem where our task is to support the following queries:</p>
<ul class="simple">
<li><p>change the value of a node</p></li>
<li><p>calculate the sum of values on a path from the root to a node</p></li>
</ul>
<p>For example, in the following tree, the sum of values from the root node to node 7 is 4+5+5=14:</p>
<p><img alt="../_images/image-20210216161623195.png" src="../_images/image-20210216161623195.png" /></p>
<p>We can solve this problem like before, but now each value in the last row of the array is the sum of values on a path from the root to the node. For example, the following array corresponds to the above tree:</p>
<p><img alt="../_images/image-20210216161645274.png" src="../_images/image-20210216161645274.png" /></p>
<p>When the value of a node increases by <em>x</em>, the sums of all nodes in its subtree increase by <em>x</em>. For example, if the value of node 4 increases by 1, the array changes as follows:</p>
<p><img alt="../_images/image-20210216161705312.png" src="../_images/image-20210216161705312.png" /></p>
<p>Thus, to support both the operations, we should be able to increase all values in a range and retrieve a single value. This can be done in <strong><em>O</em>(log <em>n</em>)</strong> time using a <strong>binary indexed or segment tree</strong>.</p>
</div>
</div>
<div class="section" id="lowest-common-ancestorlca">
<h2><span class="section-number">21.3. </span>Lowest common ancestor最近公共祖先LCA<a class="headerlink" href="#lowest-common-ancestorlca" title="Permalink to this headline">¶</a></h2>
<p>The <strong>lowest common ancestor</strong> of two nodes of a rooted tree is the lowest node whose subtree contains both the nodes. A typical problem is to efficiently process queries that ask to find the lowest common ancestor of two nodes. 给定一棵有根树，若结点 z 既是结点 x 的祖先，也是结点 y 的祖先，则成 z 是 x, y 的公共祖先。在 x, y 的所有公共祖先中，深度最大的一个称为 x, y 的最近公共祖先，记为LCA(x, y)。 LCA(x, y) 是 x 到根的路径与 y 到根的路径的交汇点，它也是 x 与 y 之间的路径上深度最小的结点。</p>
<p>For example, in the following tree, the lowest common ancestor of nodes 5 and 8 is node 2:</p>
<p><img alt="../_images/image-20210216161927484.png" src="../_images/image-20210216161927484.png" /></p>
<div class="section" id="id1">
<h3><span class="section-number">21.3.1. </span>#方法一 向上标记法<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>从 x 向上走到根结点，并标记所有经过的结点。</p>
<p>从 y 向上走到根结点，当第一次遇到已标记的结点时，就找到了 LCA(x, y)。</p>
<p>对于每个询问，向上标记法的时间复杂度最坏为 <strong><em>O</em>(n)</strong></p>
</div>
<div class="section" id="id2">
<h3><span class="section-number">21.3.2. </span>#方法二 树上倍增法<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>One way to solve the problem is to use the fact that we can efficiently find the <em>k</em>th ancestor of any node in the tree. Using this, we can divide the problem of finding the lowest common ancestor into two parts.</p>
<p>We use two pointers that initially point to the two nodes whose lowest common ancestor we should find. First, we move one of the pointers upwards so that both pointers point to nodes at the same level.（假设d[x] &gt;= d[y]，先让x走到与y同一深度。若此时x == y，说明已经找到了LCA，LCA就是y）</p>
<p>In the example scenario, we move the second pointer one level up so that it points to node 6 which is at the same level with node 5:</p>
<p><img alt="../_images/image-20210216200041024.png" src="../_images/image-20210216200041024.png" /></p>
<p>After this, we determine the minimum number of steps needed to move both pointers upwards so that they will point to the same node. The node to which the pointers point after this is the lowest common ancestor.(用二进制拆分思想，x 和 y 一起往上跳，保持深度一致，且二者不相会。此时，x, y 必定只差一步就相会了，它们的父结点 F[x, 0] 就是 LCA)</p>
<p>In the example scenario, it suffices to move both pointers one step upwards to node 2, which is the lowest common ancestor:</p>
<p><img alt="../_images/image-20210216200154400.png" src="../_images/image-20210216200154400.png" /></p>
<p>Since both parts of the algorithm can be performed in <em><em><em>O</em>(log</em>n</em>)** time using precomputed information, we can find the lowest common ancestor of any two nodes in <strong><em>O</em>(log <em>n</em>)</strong> time.</p>
</div>
<div class="section" id="euler-tour-technique">
<h3><span class="section-number">21.3.3. </span>#方法三 Euler tour technique欧拉序列<a class="headerlink" href="#euler-tour-technique" title="Permalink to this headline">¶</a></h3>
<p>Another way to solve the problem is based on a tree traversal array. Once again, the idea is to traverse the nodes using a depth-first search:</p>
<p><img alt="../_images/image-20210216201352192.png" src="../_images/image-20210216201352192.png" /></p>
<p>However, we use a different tree traversal array than before: we add each node to the array <em>always</em> when the depth-first search walks through the node, and not only at the first visit. Hence, a node that has <em>k</em> children appears <em>k</em> + 1 times in the array and there are a total of 2<em>n</em> − 1 nodes in the array.</p>
<p>We store two values in the array: the identifier of the node and the depth of the node in the tree. The following array corresponds to the above tree:</p>
<p><img alt="../_images/image-20210216201426135.png" src="../_images/image-20210216201426135.png" /></p>
<p>Now we can find the lowest common ancestor of nodes <em>a</em> and <em>b</em> by finding the node with the <em>minimum</em> depth between nodes <em>a</em> and <em>b</em> in the array. For example, the lowest common ancestor of nodes 5 and 8 can be found as follows:</p>
<p><img alt="../_images/image-20210216201457313.png" src="../_images/image-20210216201457313.png" /></p>
<p>Node 5 is at position 2, node 8 is at position 5, and the node with minimum depth between positions 2…5 is node 2 at position 3 whose depth is 2. Thus, the lowest common ancestor of nodes 5 and 8 is node 2.</p>
<p>Thus, to find the lowest common ancestor of two nodes it suffices to process a range minimum query. Since the array is static, we can process such queries in <em>O</em>(1) time after an <strong><em>O</em>(<em>n</em> log <em>n</em>)</strong> time preprocessing.</p>
</div>
<div class="section" id="tarjan">
<h3><span class="section-number">21.3.4. </span>#方法四 Tarjan算法<a class="headerlink" href="#tarjan" title="Permalink to this headline">¶</a></h3>
<p>There is also an offline algorithm for processing a set of lowest common ancestor queries. The algorithm is based on the union-find data structure, and the benefit of the algorithm is that it is easier to implement than the algorithms discussed earlier in this chapter.</p>
<p>The algorithm is given as input a set of pairs of nodes, and it determines for each such pair the lowest common ancestor of the nodes. The algorithm performs a depth-first tree traversal and maintains disjoint sets of nodes. Initially, each node belongs to a separate set. For each set, we also store the highest node in the tree that belongs to the set.</p>
<p>When the algorithm visits a node <em>x</em>, it goes through all nodes <em>y</em> such that the lowest common ancestor of <em>x</em> and <em>y</em> has to be found. If <em>y</em> has already been visited, the algorithm reports that the lowest common ancestor of <em>x</em> and <em>y</em> is the highest node in the set of <em>y</em>. Then, after processing node <em>x</em>, the algorithm joins the sets of <em>x</em> and its parent.(时间复杂度<strong><em>O</em>(n + m)</strong>)</p>
<p>For example, suppose that we want to find the lowest common ancestors of node pairs (5,8) and (2,7) in the following tree:</p>
<p><img alt="../_images/image-20210216202442054.png" src="../_images/image-20210216202442054.png" /></p>
<p>In the following trees, gray nodes denote visited nodes and dashed groups of nodes belong to the same set. When the algorithm visits node 8, it notices that node 5 has been visited and the highest node in its set is 2. Thus, the lowest common ancestor of nodes 5 and 8 is 2:</p>
<p><img alt="../_images/image-20210216202533019.png" src="../_images/image-20210216202533019.png" /></p>
<p>Later, when visiting node 7, the algorithm determines that the lowest common ancestor of nodes 2 and 7 is 1:</p>
<p><img alt="../_images/image-20210216202557890.png" src="../_images/image-20210216202557890.png" /></p>
<p>(具体再参考一下《进阶指南》P377，我感觉英文的更好理解这个过程，中文的更落脚于实现上)</p>
<p><strong>Distances of nodes结点之间的距离</strong>(应用)</p>
<p>The distance between nodes <em>a</em> and <em>b</em> equals the length of the path from <em>a</em> to <em>b</em>. It turns out that the problem of calculating the distance between nodes reduces to finding their lowest common ancestor.</p>
<p>First, we root the tree arbitrarily. After this, the distance of nodes <em>a</em> and <em>b</em> can be calculated using the formula where <em>c</em> is the lowest common ancestor of <em>a</em> and <em>b</em> and depth(<em>s</em>) denotes the depth of node <em>s</em>.</p>
<p><img alt="../_images/image-20210216163656754.png" src="../_images/image-20210216163656754.png" /></p>
<p>For example, consider the distance of nodes 5 and 8, The lowest common ancestor of nodes 5 and 8 is node 2. The depths of the nodes are depth(5) = 3, depth(8) = 4 and depth(2) = 2, so the distance between nodes 5 and 8 is 3+4−2·2=3.</p>
<p><img alt="../_images/image-20210216163739423.png" src="../_images/image-20210216163739423.png" /></p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="../%E7%BB%8F%E9%AA%8C/517.html" class="btn btn-neutral float-right" title="1. 517教学经验" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="%E6%A0%91%E4%B8%80.html" class="btn btn-neutral float-left" title="20. trees树(一)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, zqiceberg.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>