# recursive 递归

### 概念

**递归**是程序遍历状态空间的基本方式。以“原问题”为起点，尝试寻找把状态空间缩小到已知的“问题边界”的路线，再通过该路线反向回溯的遍历方式，就是递归。

程序在每个步骤应该面对相同种类的问题，这些问题都是原问题的一个子问题，可能仅在规模或者某些限制条件上有所区别，并且能够使用“求解原问题的程序”进行求解。程序在执行变换操作执行三个操作：

1. 缩小问题状态空间的规模。程序尝试寻找在 “原问题” 与 “问题边界” 之间的变换路线，并向正在探索的路线上迈进一步。
2. 尝试求解规模缩小以后的问题，可能成功，可能失败。
3. 如果成功，即找到了规模缩小后的问题的答案，那么将答案扩展到当前问题。如果失败，那么重新回到当前问题，程序可能会继续寻找当前问题的其他变换路线，直到最终确定当前问题无法求解。



**使用递归的前提：**函数理解深入（带参的函数，有返回值的函数，函数的嵌套(就是“自身调用自身”)），操作时，试验无限递归，递归的终止条件，“回溯时还原现场”保证执行前后程序面对问题的状态是相同的。

在使用枚举算法蛮力搜索问题的整个“状态空间”时，经常需要递归。（枚举算法，就是遍历一遍，逐个举例。初级的枚举很简单，就是for循环的应用，高级的就很难了，复杂在题目题目和遍历的操作方式）



### 入门例题

##### [爬楼梯](http://ybt.ssoier.cn:8088/problem_show.php?pid=1204)

/理解推导公式后，利用递归实现

##### [菲波那契数列](http://ybt.ssoier.cn:8088/problem_show.php?pid=1201)

/理解推导公式后，利用递归实现

##### [Pell数列](http://ybt.ssoier.cn:8088/problem_show.php?pid=1202)

/需要使用记忆化



### Complete search

在学习递归之后，我们就学会了遍历问题空间的一种方式方法。这样我们就可以去尝试搜索这个问题的状态空间。这里，我们先来接触Complete search（也可以理解为暴力搜索）

**Complete search** is a general method that can be used to solve almost any algorithm problem. The idea is to generate all possible solutions to the problem using brute force, and then select the best solution or count the number of solutions, depending on the problem.

Complete search is a good technique if there is enough time to go through all the solutions, because the search is usually easy to implement and it always gives the correct answer. If complete search is too slow, other techniques, such as greedy algorithms or dynamic programming, may be needed.

##### [问题：生成子集]()

For example, the subsets of {0,1,2} are 􏰀, {0}, {1}, {2}, {0,1}, {0,2}, {1,2} and {0,1,2}.

```cpp
//An elegant way to go through all subsets of a set is to use recursion
void search(int k) {
    if (k == n) {
       // process subset
    } else {
       search(k+1);
       subset.push_back(k);
       search(k+1);
       subset.pop_back();
	} 
}

search(0); //调用
//这个就是递归枚举子集
```



The following tree illustrates the function calls when *n* = 3. We can always choose either the left branch (*k* is not included in the subset) or the right branch (*k* is included in the subset).（注意反复学习这个搜索树的执行过程）



<center>

![](../media/image-20210125152214071.png)

</center>



```cpp
//Each subset of a set of n elements can be represented as a sequence of n bits, which corresponds to an integer between 0...2n −1. The ones in the bit sequence indicate which elements are included in the subset.
//上面的程序，我们使用了一个vector来存储选了什么数字
//这里，我们来学习一下位运算的枚举子集
//这是一个拓展，可以先不学

for (int b = 0; b < (1<<n); b++) {
    vector<int> subset;
    for (int i = 0; i < n; i++) {
       if (b&(1<<i)) subset.push_back(i);
    }
}
```



##### [问题：生成排列]()

For example, the permutations of {0,1,2} are (0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1) and (2,1,0).

```cpp
//Each function call adds a new element to permutation. The array chosen indicates which elements are already included in the permutation. If the size of permutation equals the size of the set, a permutation has been generated.

void search() {
    if (permutation.size() == n) {
       // process permutation
    } else {
       for (int i = 0; i < n; i++) {
           if (chosen[i]) continue;
           chosen[i] = true;
           permutation.push_back(i);
           search();
           chosen[i] = false;
           permutation.pop_back();
       }
	} 
}

search(); //调用
```

```cpp
//The C++ standard library contains the function next_permutation that can be used for this
vector<int> permutation;
for (int i = 0; i < n; i++) {
    permutation.push_back(i);
}
do {
    // process permutation
} while (next_permutation(permutation.begin(),permutation.end()));
```



### 《进阶指南》题目

##### [递归实现指数型枚举](https://www.acwing.com/problem/content/94/)

/子集枚举

```cpp
vector<int> chosen;

void dfs(int x)
{
    if (x == n + 1)   //也可以写x > n
    {
        for (int i = 0; i < chosen.size(); i++)
            printf("%d ", chosen[i]);
        puts("");

        return ;
    }

    //问：先不选x， 还是先选x。会影响我们的输出顺序
    //观察样例，我们先不选x
    
    //不选x，求解子问题
    dfs(x + 1);

    //选x，求解子问题
    chosen.push_back(x);
    dfs(x + 1);
    chosen.pop_back();  //回溯还原现场
}
```

```cpp
void dfs(int u, int state)
{
    if (u == n)
    {
        for (int i = 0; i < n; i++)
            if (state >> i & 1)
                cout << i + 1 << ' ';
        puts("");

        return ;
    }

    //求解子问题
    dfs(u + 1, state);          //不选，state初始是0，等价于dfs(u + 1, state & (~(1 << u)));
    dfs(u + 1, state | 1 << u); //选
}
```

##### [递归实现组合型枚举](https://www.acwing.com/problem/content/95/)

/在子集枚举的基础上，进行剪枝

```cpp
vector<int> chosen;

void dfs(int x)
{
    if (chosen.size() > m || chosen.size() + (n - x + 1) < m) return ;
    
    if (x == n + 1)
    {
        //如何输出状态
        for (int i = 0; i < chosen.size(); i++)
            printf("%d ", chosen[i]);
        puts("");

        return ;
    }
    //选x
    chosen.push_back(x);
    dfs(x + 1);
    chosen.pop_back();
    
    //不选x
    dfs(x + 1);
}
```

```cpp
void dfs(int u, int sum, int state)
{
    if (sum > m || sum + n - u < m) return ;
    
    if (sum == m)
    {
        for (int i = 0; i < n; i++)
            if (state >> i & 1)
                cout << i + 1 << ' ';
        puts("");
        
        return ;
    }
    
    dfs(u + 1, sum + 1, state | 1 << u);
    dfs(u + 1, sum, state);
}
```



##### [递归实现排列型枚举](https://www.acwing.com/problem/content/96/)

/排列枚举

```cpp
//用数组存方案
//注意一下0-index，如果是1-index呢？递归的边界是....？
void dfs(int k)
{
    if (k == n)
    {
        for (int i = 0; i < n; i++)
            cout << order[i] << ' ';
        puts("");
    }
    
    for (int i = 1; i <= n; i++)
    {
        if (chosen[i]) continue;
        
        order[k] = i;
        chosen[i] = true;
        
        dfs(k + 1);
        
        chosen[i] = false;
    }
}
```

```cpp
//用vector来存方案，用二进制数来记录状态
vector<int> path;

void dfs(int u, int state)
{
    if (u == n)
    {
        vector<int>::iterator i;
        for (i = path.begin(); i < path.end(); i++)
            cout << *i << ' ';
        puts("");
    }
    
    for (int i = 0; i < n; i++)
        if (!(state >> i & 1))
        {
            path.push_back(i + 1);   //用vector来记录方案
            dfs(u + 1, state | 1 << i);
            path.pop_back();
        }
}
```





### 《一本通》题目

##### [【例4.5】集合的划分](http://ybt.ssoier.cn:8088/problem_show.php?pid=1315)

/

##### [【例4.6】数的计数(Noip2001)](http://ybt.ssoier.cn:8088/problem_show.php?pid=1316)

/

##### [逆波兰表达式](http://ybt.ssoier.cn:8088/problem_show.php?pid=1198)

/

##### [全排列](http://ybt.ssoier.cn:8088/problem_show.php?pid=1199)

/

##### [分解因数](http://ybt.ssoier.cn:8088/problem_show.php?pid=1200)

/

##### [菲波那契数列](http://ybt.ssoier.cn:8088/problem_show.php?pid=1201)

/

##### [Pell数列](http://ybt.ssoier.cn:8088/problem_show.php?pid=1202)

/

##### [扩号匹配问题](http://ybt.ssoier.cn:8088/problem_show.php?pid=1203)

/

##### [爬楼梯](http://ybt.ssoier.cn:8088/problem_show.php?pid=1204)

/

##### [汉诺塔问题](http://ybt.ssoier.cn:8088/problem_show.php?pid=1205)

/

##### [放苹果](http://ybt.ssoier.cn:8088/problem_show.php?pid=1206)

/

##### [求最大公约数问题](http://ybt.ssoier.cn:8088/problem_show.php?pid=1207)

/

##### [2的幂次方表示](http://ybt.ssoier.cn:8088/problem_show.php?pid=1208)

/

##### [分数求和](http://ybt.ssoier.cn:8088/problem_show.php?pid=1209)

/

##### [因子分解](http://ybt.ssoier.cn:8088/problem_show.php?pid=1210)

/

##### [判断元素是否存在](http://ybt.ssoier.cn:8088/problem_show.php?pid=1211)

/