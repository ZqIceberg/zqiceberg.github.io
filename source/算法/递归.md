# recursive 递归

### 概念

递推是程序遍历状态空间的基本方式。以“原问题”为起点尝试寻找把状态空间缩小到已知的“问题边界”的路线，再通过该路线反向回溯的遍历方式就是递归。

程序在每个步骤应该面对相同种类的问题，这些问题都是原问题的一个子问题，可能仅在规模或者某些限制条件上有所区别，并且能够使用“求解原问题的程序”进行求解。程序在执行变换操作执行三个操作：

1. 缩小问题状态空间的规模。程序尝试寻找在“原问题”与“问题边界”之间的变换路线，并向正在探索的路线上迈进一步。
2. 尝试求解规模缩小以后的问题，可能成功，可能失败。
3. 如果成功，即找到了规模缩小后的问题的答案，那么将答案扩展到当前问题。如果失败，那么重新回到当前问题，程序可能会继续寻找当前问题的其他变换路线，直到最终确定当前问题无法求解。



使用递归的前提，函数理解深入（带参的函数，有返回值的函数，函数的嵌套(就是“自身调用自身”)），操作时，试验无限递归，递归的终止条件，“回溯时还原现场”保证执行前后程序面对问题的状态是相同的。

在使用枚举算法蛮力搜索问题的整个“状态空间”时，经常需要递归。（枚举算法，就是遍历一遍，逐个举例。初级的枚举很简单，就是for循环的应用，高级的就很难了，复杂在题目题目和遍历的操作方式）

### Complete search

**Complete search** is a general method that can be used to solve almost any algorithm problem. The idea is to generate all possible solutions to the problem using brute force, and then select the best solution or count the number of solutions, depending on the problem.

Complete search is a good technique if there is enough time to go through all the solutions, because the search is usually easy to implement and it always gives the correct answer. If complete search is too slow, other techniques, such as greedy algorithms or dynamic programming, may be needed.

##### [问题：生成子集]()

For example, the subsets of {0,1,2} are 􏰀, {0}, {1}, {2}, {0,1}, {0,2}, {1,2} and {0,1,2}.

```cpp
//An elegant way to go through all subsets of a set is to use recursion

void search(int k) {
    if (k == n) {
       // process subset
    } else {
       search(k+1);
       subset.push_back(k);
       search(k+1);
       subset.pop_back();
	} 
}

search(0); //调用

//这个就是递归枚举子集
```

```cpp
//Each subset of a set of n elements can be represented as a sequence of n bits, which corresponds to an integer between 0...2n −1. The ones in the bit sequence indicate which elements are included in the subset.

for (int b = 0; b < (1<<n); b++) {
    vector<int> subset;
    for (int i = 0; i < n; i++) {
       if (b&(1<<i)) subset.push_back(i);
    }
}
```

##### [问题：生成排列]()

For example, the permutations of {0,1,2} are (0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1) and (2,1,0).

```cpp
//Each function call adds a new element to permutation. The array chosen indicates which elements are already included in the permutation. If the size of permutation equals the size of the set, a permutation has been generated.

void search() {
    if (permutation.size() == n) {
       // process permutation
    } else {
       for (int i = 0; i < n; i++) {
           if (chosen[i]) continue;
           chosen[i] = true;
           permutation.push_back(i);
           search();
           chosen[i] = false;
           permutation.pop_back();
       }
	} 
}

search(); //调用
```

```cpp
//The C++ standard library contains the function next_permutation that can be used for this
vector<int> permutation;
for (int i = 0; i < n; i++) {
    permutation.push_back(i);
}
do {
    // process permutation
} while (next_permutation(permutation.begin(),permutation.end()));
```



### 《进阶指南》题目

##### [递归实现指数型枚举](https://www.acwing.com/problem/content/94/)

/

##### [递归实现组合型枚举](https://www.acwing.com/problem/content/95/)

/

##### [递归实现排列型枚举](https://www.acwing.com/problem/content/96/)

/



### 《一本通》题目

##### [【例4.5】集合的划分](http://ybt.ssoier.cn:8088/problem_show.php?pid=1315)

/

##### [【例4.6】数的计数(Noip2001)](http://ybt.ssoier.cn:8088/problem_show.php?pid=1316)

/

##### [逆波兰表达式](http://ybt.ssoier.cn:8088/problem_show.php?pid=1198)

/

##### [全排列](http://ybt.ssoier.cn:8088/problem_show.php?pid=1199)

/

##### [分解因数](http://ybt.ssoier.cn:8088/problem_show.php?pid=1200)

/

##### [菲波那契数列](http://ybt.ssoier.cn:8088/problem_show.php?pid=1201)

/

##### [Pell数列](http://ybt.ssoier.cn:8088/problem_show.php?pid=1202)

/

##### [扩号匹配问题](http://ybt.ssoier.cn:8088/problem_show.php?pid=1203)

/

##### [爬楼梯](http://ybt.ssoier.cn:8088/problem_show.php?pid=1204)

/

##### [汉诺塔问题](http://ybt.ssoier.cn:8088/problem_show.php?pid=1205)

/

##### [放苹果](http://ybt.ssoier.cn:8088/problem_show.php?pid=1206)

/

##### [求最大公约数问题](http://ybt.ssoier.cn:8088/problem_show.php?pid=1207)

/

##### [2的幂次方表示](http://ybt.ssoier.cn:8088/problem_show.php?pid=1208)

/

##### [分数求和](http://ybt.ssoier.cn:8088/problem_show.php?pid=1209)

/

##### [因子分解](http://ybt.ssoier.cn:8088/problem_show.php?pid=1210)

/

##### [判断元素是否存在](http://ybt.ssoier.cn:8088/problem_show.php?pid=1211)

/