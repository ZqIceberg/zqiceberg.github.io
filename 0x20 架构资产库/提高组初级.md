[toc]

## 1 枚举

#### [A - Flip Game](https://vjudge.net/contest/299759#problem/A)

暴力枚举，二进制枚举

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

const int N = 20;

char s[N][N];
int res = 20;

void change(int x, int y)
{
	int dx[] = {0, 1, 0, -1, 0}, dy[] = {1, 0, -1, 0, 0};
	for (int i = 0; i < 5; i++)
	{
		int a = x + dx[i], b = y + dy[i];
		if (a >= 0 && a < 4 && b >= 0 && b < 4)
		{
			if (s[a][b] == 'w') s[a][b] = 'b';
			else s[a][b] = 'w';
		}
	}
}

bool check()
{	
	char t = s[0][0];

	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++)
			if (s[i][j] != t) return false;

	return true;
}

void dfs(int dep, int used)
{
	if (dep == 16)
	{
		if (check()) res = min(res, used);

		return ;
	}

	dfs(dep + 1, used);

	int x = dep / 4;
	int y = dep % 4;
	change(x, y);
	dfs(dep + 1, used + 1);
	change(x, y);
}

int main()
{
	for (int i = 0; i < 4; i++) scanf("%s", s[i]);

	dfs(0, 0);

	if (res == 20) printf("Impossible\n");
	else printf("%d\n", res);

	return 0;
}

```

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

const int N = 20;

char s[N][N];
int res = 20;

void change(int u)
{
	int x = u / 4, y = u % 4;
	int dx[] = {0, 1, 0, -1, 0}, dy[] = {1, 0, -1, 0, 0};
	
	for (int i = 0; i < 5; i++)
	{
		int a = x + dx[i], b = y + dy[i];
		if (a >= 0 && a < 4 && b >= 0 && b < 4)
		{
			if (s[a][b] == 'w') s[a][b] = 'b';
			else s[a][b] = 'w';
		}
	}
}

bool check()
{
	char t = s[0][0];

	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++)
			if (s[i][j] != t) return false;

	return true;
}

int main()
{
	for (int i = 0; i < 4; i++) scanf("%s", s[i]);

	int used = 0;
	for (int mask = 0; mask < (1 << 16); mask++)  //二进制枚举
	{
		for (int j = 0; j < 16; j++)
			if (mask & (1 << j))
			{
				change(j);
				used++;
			}
		
		if (check()) res = min(res, used);

		for (int j = 0; j < 16; j++)
			if (mask & (1 << j))
			{
				change(j);
				used--;
			}
	}

	if (res == 20) printf("Impossible\n");
	else printf("%d\n", res);

	return 0;
}

```

#### [B - Subsequence](https://vjudge.net/problem/UVA-1121)

双指针

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 100010;

int a[N], s[N];
int n, m;

int main()
{
	while (scanf("%d%d", &n, &m) == 2)
	{
		for (int i = 1; i <= n; i++) scanf("%d", &a[i]);

		int ans = n + 1;
		int sum = 0;
		
		for (int i = 1, j = 0; i <= n; i++)
		{
			while (j + 1 <= n && sum < m) sum += a[j + 1], j++;

			if (sum >= m)
				ans = min(ans, j + 1 - i);

			sum -= a[i];
		}

		if (ans == n + 1) ans = 0;
		printf("%d\n", ans);
	}
	return 0;
}

```

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 100010;

int a[N], s[N];
int n, m;

int main()
{
	while (scanf("%d%d", &n, &m) == 2)
	{
		for (int i = 1; i <= n; i++) scanf("%d", &a[i]);

		int ans = n + 1;
		int sum = 0;
		
		for (int i = 1, j = 1; i <= n; i++)
		{
			while (j <= n && sum < m) sum += a[j++];

			if (sum >= m)
			{
				//printf("---%d %d %d\n", i, j, sum);
				ans = min(ans, j - i);
			}

			sum -= a[i];
		}

		if (ans == n + 1) ans = 0;
		printf("%d\n", ans);
	}
	return 0;
}
```

#### [C - Xor Sum 2](https://vjudge.net/problem/AtCoder-arc098_b)

异或

a ^ b < a + b，说明有位置上是重复的，一旦小于，后面再异或上其他数，也不会等于了

```cpp
/****
	双指针，右指针先往右跑, 左指针发现不符合条件的就移动一格
****/

#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

const int N = 2e5 + 10;

int a[N];
int n;

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);

	LL suma = 0, sumb = 0;
	LL ans = 0;
	for (int j = 1, i = 1; j <= n; j++)  //先枚举右端点, 右端点往前跑
	{
		suma ^= a[j], sumb += a[j];
		
		while (i <= j && suma != sumb)
		{
			suma ^= a[i], sumb -= a[i];
			i++;
		}
		
		ans += j - i + 1;
	}

	printf("%lld\n", ans);

	return 0;
}
```

```cpp
//先枚举左端点
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

const int N = 2e5 + 10;

int a[N];
int n;

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);

	LL suma = 0, sumb = 0;
	LL ans = 0;

	for (int i = 1, j = 1; i <= n; i++)  //枚举左端点
	{
		while (j - 1 <= n && suma == sumb) //滑动右窗口
		{
			suma ^= a[j], sumb += a[j];
			j++;
		}

		ans += j - 1 - i;

		suma ^= a[j - 1], sumb -= a[j - 1];	
		suma ^= a[i], sumb -= a[i];	
		j--;
	}

	printf("%lld\n", ans);

	return 0;
}


```



> 各种枚举要练熟，叠加给其他算法的时候，不用再去学习琐碎的知识

#### [D - Maximum Subsequence](https://vjudge.net/problem/CodeForces-888E)折半枚举

1 ≤ *n* ≤ 35, 这个数是有提示的，2^35会爆，但是开一个更号2^18刚好

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 5e5 + 10;

int a[40];
int b1[N], b2[N];
int n, mod;

int main()
{
	//printf("%lld\n", (long long)1 << 18);

	scanf("%d%d", &n, &mod);

	for (int i = 0; i < n; i++){scanf("%d", &a[i]); a[i] %= mod;}

	int m1 = n / 2;
	int len1 = 0;
	for (int i = 0; i < (1 << m1); i++)
	{
		int t = 0;
		for (int j = 0; j < m1; j++)
			if (i & (1 << j))
				t = (t + a[j]) % mod;

		b1[len1++] = t;
	}
	sort(b1, b1 + len1);

	int m2 = n - m1;
	int len2 = 0;
	for (int i = 0; i < (1 << m2); i++)
	{
		int t = 0;
		for (int j = 0; j < m2; j++)
			if (i & (1 << j))
			{
				int jj = m1 + j;
				t = (t + a[jj]) % mod;
			}

		b2[len2++] = t;
	}
	sort(b2, b2 + len2);

	//预处理完毕，开始折半枚举
	int ans = -1;

	for (int i = 0; i < len1; i++)
	{
		int x = b1[i];
		int y = mod - 1 - x;
		int p = upper_bound(b2, b2 + len2, y) - b2 - 1;
		
		ans = max(ans, (x + b2[p]) % mod);
	}

	for (int i = 0; i < len2; i++)
	{
		int x = b2[i];
		int y = mod - 1 - x;
		int p = upper_bound(b1, b1 + len1, y) - b1 - 1;

		ans = max(ans, (x + b1[p]) % mod);
	}

	printf("%d\n", ans);
	
	return 0;
}

```



## 2 贪心



> 课上，听懂思路，课后练习
>
> 核心代码，删了再写，多谢两边，才能写会

#### [A - A](https://vjudge.net/problem/OpenJ_Bailian-2376)

区间覆盖

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef pair<int, int> PII;

const int N = 25010;

PII a[N];
int n, m;

int main()
{
	scanf("%d%d", &n, &m);

	for (int i = 0; i < n; i++) scanf("%d%d", &a[i].first, &a[i].second);

	sort(a, a + n);

	int last = 0, ed = 0;
	int cnt = 0;

	for (int i = 0; i < n; i++)
	{
		int j = i;
		while (j < n && a[j].first <= last + 1)
		{
			ed = max(ed, a[j].second);
			j++;
		}

		if (ed < last + 1) break;
		
		cnt++;
		if (ed >= m) break;

		last = ed;
		i = j - 1;
	}

	if (ed < m) printf("-1\n");
	else printf("%d\n", cnt);
	
	return 0;
}
```

#### [B - B](https://vjudge.net/problem/HDU-2037) [HDU - 2037](https://vjudge.net/problem/HDU-2037/origin)

区间覆盖

```cpp
#include <cstdio>
#include <vector>
#include <iostream>

using namespace std;

typedef pair<int, int> PII;

int n;

int main()
{
	while (scanf("%d", &n) == 1 && n)
	{
		vector<PII> segs(n);
		for (int i = 0; i < n; i++) scanf("%d %d", &segs[i].second, &segs[i].first);

		sort(segs.begin(), segs.end());

		int ed = -1;
		int cnt = 0;
		for (int i = 0; i < n; i++)
			if (segs[i].second >= ed)
			{
				cnt++;
				ed = segs[i].first;
			}

		printf("%d\n", cnt);
	}

	return 0;
}

```

#### [C - C](https://vjudge.net/problem/POJ-1328) [POJ - 1328](https://vjudge.net/problem/POJ-1328/origin)

转化为区间覆盖问题

```cpp
/*
	可以用自定义结构体
	也可以用pair<double, double>，开一个vector
	另外，读入数据的环节，确实特别坑，如果遇到超过半径的点，不能直接break掉，要把剩余的数据读完整，因为是多组测试数据
*/

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cmath>

using namespace std;

typedef pair<double, double> PDD;

const int N = 1010;
const double eps = 1e-6;

/*
struct Segs
{
	double l, r;
	
	bool operator< (const Segs& W)const
	{
		return r + eps < W.r;
	}
}segs[N];
*/

int n, d;

int main()
{
	int idx = 0;
	while (scanf("%d%d", &n, &d) == 2 && n != 0 && d != 0)
	{
		vector<PDD> segs(n);

		idx++;
		bool flag = false;
		for (int i = 0; i < n; i++)
		{
			double x, y;
			scanf("%lf%lf", &x, &y);
			
			if (fabs(y) > d) flag = true;

			double delta = sqrt(1.0 * d * d - y * y);
			segs[i].second = x - delta, segs[i].first = x + delta;
		}

		if (flag)
			printf("Case %d: -1\n", idx);
		else
		{
			sort(segs.begin(), segs.end());

			int cnt = 0;
			double ed = -2e9;
			for (int i = 0; i < n; i++)
			{
				if (ed + eps < segs[i].second)
				{
					cnt++;
					ed = segs[i].first;
				}
			}

			printf("Case %d: %d\n", idx, cnt);
		}
	}

	return 0;
}

```

#### [D - D](https://vjudge.net/problem/POJ-3617) [POJ - 3617](https://vjudge.net/problem/POJ-3617/origin), 字典序问题

```cpp
#include <cstdio>

using namespace std;

const int N = 2010;

char s[N], ans[N];
int n;

int main()
{
	//freopen("data.in", "r", stdin);

	scanf("%d", &n);

	for (int i = 0; i < n; i++)
	{
		char op[2];
		scanf("%s", op);
		
		s[i] = op[0];
	}

	int l = 0, r = n - 1;
	for (int i= 0; i < n; i++)
	{
		int ll = l, rr = r;
		while (s[ll] == s[rr] && ll < rr) ll++, rr--;

		if (s[ll] < s[rr]) ans[i] = s[l++];
		else ans[i] = s[r--];
	}
	
	int m = 0;
	for (int i = 0; i < n; i++)
	{
		printf("%c", ans[i]);
		m++;
		if (m % 80 == 0)
		{
			m = 0;
			puts("");
		}
	}

	return 0;
}

```



生成测试数据

```cpp
#include <bits/stdc++.h>

using namespace std;

char s[220];

int main()
{
	freopen("data.in", "w", stdout);

	cout << 200 << endl;

	int m = 0;
	for (int i = 0; i < 200; i++)
	{
		printf("%c\n", 'A' + m);
		m++;
		if (m == 26) m = 0;
	}

	return 0;
}
```

#### [E - E](https://vjudge.net/problem/HDU-4864) [HDU - 4864](https://vjudge.net/problem/HDU-4864/origin)

区间问题，排序掉一维问题，就可以少考虑一维问题，

选择性价比最大的去选择





## 3 STL

## 4 二分，三分，01分数

## 5 动态规划基础训练

## 6 状态压缩dp

## 7 倍增算法

## 8 单调队列，单调栈，dp优化

## 9 树结构基础训练

## 10 图论基础训练

