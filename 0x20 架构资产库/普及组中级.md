[TOC]

## 11_STL入门

#### 3440 - 统计数字

使用map

#### 3460 - 战士

使用vector

#### 3470 - multiset常规操作

set 和 multiset

#### 3485 - 合并果子

使用priority_queue，大根堆，小根堆的写法

#### 4040 - 第三课：水果店

map的深度使用，输入输出也是个考验
map<PII, int>  把pair作为key

#### 4041 - 第三课：Set

set里的二分查找



## 12_贪心

#### 3490 - 看电影

区间问题，很多贪心都是这种
按左端点排序，每一个区间谁先结束要谁
用一个vector来维护res，有符合条件的就push_back，发现更合适的就pop_back

#### 3500 - 覆盖数轴

按区间左端点排序，选右端点尽可能远的区间。如果无法衔接上，break，如果已经超过目标位置，break

#### 3510 - 区间覆盖

按区间右端点排序，选择第一个区间的右端点作为第一个标记，往后遍历，看能不能覆盖后面区间的左端点。如果不能覆盖，就要新选一个区间

#### 3520 - 打地鼠Ⅱ

按分值从大到小排序
把每一秒作成标记数组维护每一秒有无被使用
对于一个地鼠，从他生命周期从后往前遍历，当发现这一秒，没有打，就用这一秒来打这个地鼠

#### 3990 - 第二课：最小字典序

未AC，感觉测试点输出格式有问题

#### 4000 - 第二课：雷达

把雷达能够覆盖的范围，映射到x轴上，就转化为了区间问题
转化为了区间覆盖问题，按右端点排序



## 13_哈希与链表

#### A. 图书管理

用map<string, int>开哈希

#### 3610 - 单向链表操作

数组模拟单链表

#### 3620 - 约瑟夫环

数组模拟双向链表

#### 3630 - 大整数查找

手写hash函数
bool find(int x)
void insert(int x)



## 14_栈与队列

#### 3670 - 食堂排队

之前用单链表模拟，头插法，尾插法，都是自研出来的
头插尾插的原因是，当时不知道该如果处理，初始化的时候如何每个班级里的人是正序排队的
后面操作的时候却插入队头

现在明白了
把读入先存起来，初始化stack的时候，倒序来一遍push进栈，就完成正序了

queue<int>维护那个班级站在前面
cnt[N] 这个班级队列中有多少人
stack<int> stk[N] 维护每个班级的小队伍
queue中的班级编号和stk[] cnt[]都有一个映射的关系逻辑在这

#### 3640 - 括号匹配

用一个栈维护左括号的位置，发现一个左括号，把左括号的位置入栈
发现一个右括号，就把栈顶的左括号的位置和右括号的位置输出

#### 3660 - 栈

用三个stack<int>，来模拟操作序列，栈，答案
n <= 10，用暴力做法，递归，那么操作序列要能够递归回溯，所以需要用栈结构，pop()，再push()回来

dfs里面包含
if (!from.empty())
	{
		//取出from栈顶元素,放到to里面

if (!to.empty())
	{
		int t = to.top();
		to.pop();
		ans.push(t);

#### 3650 - 最长合法子串

stack<int> stk;
char s[N];
int f[N];
//f[]记录以这个点为终点的最长合法子串长度，仅对右括号记录
//一个合法的子串，还要判断这个子串的前一位是不是右括号，如果是，这个合法子串的长度，要加上前一个合法子串的长度，更新f[i]
//要stack记录左括号的位置，读到右括号的时候，用相对位置计算合法子串长度
//再用stack用左括号的位置，去看子串前一个位置是不是右括号，是就更新f[i]



## 15_广度优先搜索(广搜) 

#### 3680 - 二叉树的层次遍历

int g[N][2]; //g[i][0]左儿子 g[i][1]右儿子
用二维矩阵来存储二叉树

#### 3700 - 迷宫

棋盘上的BFS

#### 3710 - 拼图游戏

//怎么标记，手写哈希
//怎么编码，怎么解码
特别经典的题目

#### 3690 - 自由领地

棋盘上的BFS

#### 3720 - 相约KFC

从我出发，从朋友出发，来两边bfs，标记分别到大KFC的最少步数
然后枚举一遍KFC，找到步数最小的那个点

#### 3740 - 倒酒

考察点状态的表示

#### 3741 - 数字转换



## 16_图论入门

#### 3750 - 树的深度

用邻接矩阵来存树，dfs(1)
还需要维护当前的点的深度，再传一个深度进去dfs(1, 1)

#### 3755 - 图上最短路(边权为1)

用邻接表建图

#### 3760 - 树的深度加强

数据范围10^5
用邻接表建树

#### 3770 - 连通块的个数

用邻接表建树
//1到n，dfs下去，每进行一次dfs就是找到一个连通块
//在枚举出边的时候，if(!st[e[i]]) dfs(e[i]);  别写成了if (!st[i]) dfs(i);  注意代表的含义要是的连接的点，不是边的编号

#### 3780 - 树上两点距离

用邻接表存储
从起点出发dfs，
需要把父结点传进去，因为不能走回头路
把距离传进去
dfs(s, -1, 0);  //从s开始，当前的父亲节点是-1，距离是0

#### 3790 - 每个点的子树大小

用邻接表存储
用d[N]来维护每一个点的子树大小
	for (int i = h[u]; i != -1; i = ne[i])
	{
		dfs(e[i]);
		d[u] += d[e[i]];
	}

#### 3800 - 最近公共祖先

向上标记法



## 17_最小生成树

#### 3840 - 最小生成树prim

S集合，T集合

#### 3860 - 黑白树

特别经典
	最少几条白边，minn
	最多几条白边，maxn
	minn~maxn之前的方案，是都可以凑出来的，可以减一条黑边，加一条白边

	问题转化为，minn~maxn之间，有没有fibo值
	
	用kruscal求用多少条白边
	黑边排在前面，就可以求出最少用多少条白边
	白边排在前面，就可以求出最多用多少条白边

#### 3850 - 最小生成树kruskal

建立并查集
每条边按权值从小到大排序，扫描每一条边{a, b, w}
如果a, b属于一个集合，过
如果a, b不属于一个集合，a的父亲指向b的父亲，合并，累加w进答案
扫描完成后，最小生成树的点数，小于n-1就表明无法构成生成树



## 18_最短路径

#### 3815 - 普通最短路-邻接矩阵建图

朴素dijkstra

#### 3820 - 加强版最短路-邻接表建图

堆优化dijkstra

#### 3810 - 奇怪的电梯

朴素dijkstra

#### 3830 - 有负环最短路径

Bellman-Ford



## 19_递推动态规划入门

#### 3870 - 最长递增子序列

#### 3880 - 最长公共子序列

#### 3890 - 数塔问题

#### 3910 - 最大子矩阵

问题转化为求最大子段和
	枚举两行i, j， 把ij之间的数字，求和压缩成一个数，那么就转化成了一行数字中，哪个子段和最大
	枚举i，枚举j，枚举k，O(n^3)

	若利用二维前缀和
	需要O(n^4)，枚举左上角，右下角两个点
	
	求最大子段和
	f[i]状态，表示以i结尾的最大子段和，f[i] = f[i-1]+a[i] 或者f[i] = a[i]

#### E. 对局匹配

先sort一遍预处理
状态表示f[i]，在序列前i个人中，选取3个人，满足两两分数差不超过k的所有选法
属性，求max
状态计算，不选i这个人，选i这个人
f[i - 1]
满足a[i] - a[i-2]<=k的条件下，可以选这个人，如果选这个人就会多一种选法，f[i-3]+1

for一遍，从i=3开始循环

#### 3920 - 回文字符串

原字符串，翻转后的字符串
求两个字符串的最长公共子序列

#### 3900 - 括号匹配

1.记忆化搜索
dfs(1, n)
判断左端点，右端点是否匹配
如果匹配，就可以往里缩小范围
否则在区间里，枚举k，切分成两个区间往下搜索

2.递推
	for (int len = 2; len <= n; len++)
		for (int i = 1; i + len - 1 <= n; i++)
					int j = i + len - 1;
外层循环枚举长度，内层循环枚举左端点，j是右端点
剩下的搜索的方式一样，左右两端点匹配，往里缩小范围
否则枚举k，切分成两个区间

这道题的实现过程，和“石子合并”很相似



## 20_背包问题

#### 3930 - 01背包

#### 3940 - 分蛋糕

#### C. 完全背包

很多题库里，完全背包的模板题并不开放

