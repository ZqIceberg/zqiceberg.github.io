#### 3490 - 看电影

```cpp
//下面三种方式，时间、空间的消耗，从小到大排序
//1.写结构体，重载小于符号
//2.写结构体，用cmp函数，定义排序
//3.用pair的排序性质

#include <iostream>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;

const int N = 1e5 + 10;

struct Film
{
	int l, r;

/*
	bool operator< (const Film& W)const
	{
		return r < W.r;
	}
*/
}a[N];

bool cmp(Film &a, Film &b)
{
	return a.r < b.r;
}

PII b[N];

int n;

int main()
{
	scanf("%d", &n);
	for (int i = 0; i < n; i++)
	{
		scanf("%d%d", &a[i].l, &a[i].r);

/*
		int l, r;
		scanf("%d%d", &l, &r);
		b[i].first = r, b[i].second = l;
*/
}

	sort(a, a + n, cmp);

	int R = -1, cnt = 0;
	for (int i = 0; i < n; i++)
	{
		if (a[i].l > R)
		{
			R = a[i].r;
			cnt++;
		}

	/*
		int l = b[i].second, r = b[i].first;
		if (l > R)
		{
			R = r;
			cnt++;
		}
	*/
	}

	printf("%d\n", cnt);

	return 0;
}
```



```cpp
#include <iostream>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;

const int N = 1e5 + 10;

struct Film
{
	int l, r;

	bool operator< (const Film& W)const
	{
		return r < W.r;
	}
}a[N];

PII b[N];

int n;

int main()
{
	scanf("%d", &n);
	for (int i = 0; i < n; i++)
	{
		//scanf("%d%d", &a[i].l, &a[i].r);

		int l, r;
		scanf("%d%d", &l, &r);
		b[i].first = r, b[i].second = l;
	}

	sort(b, b + n);

	int R = -1, cnt = 0;
	for (int i = 0; i < n; i++)
	{
		int l = b[i].second, r = b[i].first;
		if (l > R)
		{
			R = r;
			cnt++;
		}
	}

	printf("%d\n", cnt);

	return 0;
}
```



```cpp
#include <iostream>
#include <algorithm>
#include <set>

using namespace std;

typedef pair<int, int> PII;

set<PII> st;

int main()
{
	int n;
	scanf("%d", &n);

	while (n--)
	{
		int l, r;
		scanf("%d%d", &l, &r);

		st.insert(make_pair(r, l));
	}

	int R = -1, cnt = 0;
	for (set<PII>::iterator it = st.begin(); it != st.end(); it++)
	{
		int r = (*it).first, l = (*it).second;
		if (l > R)
		{
			R = r;
			cnt++;
		}
	}

	printf("%d\n", cnt);

	return 0;
}
```



#### 3500-覆盖数轴

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

struct Seg
{
	int l, r;

	bool operator< (const Seg &W)const
	{
		return l < W.l;
	}
}seg[N];

int main()
{
	int n, m;
	scanf("%d%d", &n, &m);

	for (int i = 0; i < n; i++)
		scanf("%d%d", &seg[i].l, &seg[i].r);

	sort(seg, seg + n);
	
	int cnt = 0; //选了几个点
	int R = 0;	//R是当前选取的标记
	int ed = 0; //能覆盖的最远距离
	for (int i = 0, j; i < n; i = j)
	{
		j = i;
		//这个区间的左端点<=R+1,这个区间能覆盖标记，并且右边覆盖最远，就用这个区间
		while (j < n && seg[j].l <= R + 1)
		{
			ed = max(ed, seg[j].r);
			j++;
		}

		//覆盖不完整，有断档区间
		if (ed < R + 1) break;
		
		cnt++;
		R = ed; //更新标记为最远的位置，后面区间的左端点能覆盖这个标记即可
		if (ed >= m) break;
	}

	if (R < m) printf("-1\n");
	else printf("%d\n", cnt);

	return 0;
}
```

#### 3510 - 区间覆盖

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

struct Seg
{
	int l, r;
	bool operator< (const Seg& W)const
	{
		return r < W.r;
	}
}seg[N];

int main()
{
	int n, m;
	scanf("%d%d", &n, &m);

	for (int i = 0; i < n; i++)
		scanf("%d%d", &seg[i].l, &seg[i].r);

	sort(seg, seg + n);

	int r = seg[0].r;
	int cnt = 1;
	for (int i = 1; i < n; i++)
	{
		int j = i;
		while (j < n && seg[j].l <= r) j++;

		if (j >= n) break; //完成覆盖任务

		r = seg[j].r;
		cnt++;
		i = j - 1;
	}
	
	printf("%d\n", cnt);

	return 0;
}
```



```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

struct Seg
{
	int l, r;
	bool operator< (const Seg& W)const
	{
		return r < W.r;
	}
}seg[N];

int main()
{
	int n, m;
	scanf("%d%d", &n, &m);

	for (int i = 0; i < n; i++)
		scanf("%d%d", &seg[i].l, &seg[i].r);

	sort(seg, seg + n);

	int last = -2e9;
	int cnt = 0;
	for (int i = 0; i < n; i++)
	{
		if (seg[i].l > last)
		{
			cnt++;
			last = seg[i].r;
		}
	}

	printf("%d\n", cnt);

	return 0;
}
```



##### 3750 - 树的深度

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;

int g[N][N];
int n;
int res;

void dfs(int u, int depth)
{
	if (depth > res) res = depth;

	for (int i = 1; i <= n; i++)
		if (g[u][i] == 1)
			dfs(i, depth + 1);
}

int main()
{
	scanf("%d", &n);

	for (int i = 2; i<= n; i++)
	{
		int x;
		scanf("%d", &x);

		g[x][i] = 1;
	}
	
	dfs(1, 1); //当前从1开始，深度是1

	printf("%d\n", res);

	return 0;
}	
```



##### 3755 - 图上最短路(边权为1)

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 5010, M = 8010;

int h[N], e[M * 2], ne[M * 2], idx;
int d[N];
int n, m;
int s, t;

void add(int a, int b)
{
	e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

void bfs(int u)
{
	queue<int> q;
	q.push(u);
	d[u] = 0;

	while (!q.empty())
	{
		int t = q.front();
		q.pop();

		for (int i = h[t]; i != -1; i = ne[i])
		{
			if (d[e[i]] == -1)
			{
				d[e[i]] = d[t] + 1;
				q.push(e[i]);
			}
		}
	}
	
}

int main()
{
	memset(h, -1, sizeof h);
	memset(d, -1, sizeof d);

	scanf("%d%d", &n, &m);
	while (m--)
	{
		int a, b;
		scanf("%d%d", &a, &b);

		add(a, b);
		add(b, a);
	}

	scanf("%d%d", &s, &t);

	bfs(s);

	printf("%d\n", d[t]);

	return 0;
}
```



##### 3770 - 连通块的个数

```cpp
//1到n，dfs下去，每进行一次dfs就是找到一个连通块
//在枚举出边的时候，if(!st[e[i]]) dfs(e[i]);  别写成了if (!st[i]) dfs(i);  注意代表的含义要是的连接的点，不是边的编号

#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;

int h[N], e[N * 2], ne[N * 2], idx;
bool st[N];
int n, m;
int res;

void add(int a, int b)
{
	e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

void dfs(int u)
{
	st[u] = true;
	//printf("---%d\n", u);
	
	for (int i = h[u]; i != -1; i = ne[i])
		if (!st[e[i]]) dfs(e[i]);  //枚举每一条出边，如果连接的点没有被遍历过，就dfs这个点
}

int main()
{
	scanf("%d%d", &n, &m);

	memset(h, -1, sizeof h);

	while (m--)
	{
		int a, b;
		scanf("%d%d", &a, &b);

		add(a, b);
		add(b, a);
	}

	for (int i = 1; i <= n; i++)
		if (!st[i])
		{
			dfs(i);
			res++;
		}

	printf("%d\n", res);

	return 0;
}
```

