!(https://cdn.luogu.com.cn/upload/image_hosting/vtkueesx.png)

#### T122175 递归方法求1..n的和
高斯公式实现，for循环实现
用从尾巴一点一点砍的方式，画图讲解递归。BOSS和员工的例子
```cpp
#include <iostream>
#include <fstream>

using namespace std;

int dfs(int x)
{
    if (x == 1) return 1;

    return dfs(x - 1) + x;
}

int main()
{
    int n;
    cin >> n;

    cout << dfs(n) << endl;

    return 0;
}
```


#### T122173 爬楼梯
第一种方法，画最后三阶楼梯的走法，引申出前面楼梯怎面走
第二种方法，从第一种楼梯走，画搜索树，正向搜索
```cpp
#include <iostream>
#include <fstream>

using namespace std;

int func(int n)
{
    if (n == 1) return 1;
    if (n == 2) return 2;

    return func(n - 1) + func(n - 2);
}

int main()
{
    //freopen("louti02.in", "r", stdin);
    //freopen("louti02.out", "w", stdout);

    int n;
    while(cin >> n)
        cout << func(n) << endl;

    return 0;
}
```

#### T122420 递归方法求fibo
从后往前画图，画序列
```cpp
#include <iostream>
#include <fstream>

using namespace std;

int fibo(int n)
{
    if (n == 1) return 1;
    if (n == 0) return 0;

    return fibo(n - 1) + fibo(n - 2);
}

int main()
{
    //freopen("fibo2.in", "r", stdin);
    //freopen("fibo2.out", "w", stdout);

    int n;
    cin >> n;

    cout << fibo(n) << endl;

    return 0;
}
```

#### T122421 汉诺塔问题1
第一次接触汉诺塔，输出从哪个柱子移动到哪个柱子，还要写清楚是第几步骤，这个不好理解
还有三个参数的实参，为什么换位置
```cpp
#include <iostream>
#include <cstdio>
#include <fstream>

using namespace std;

int step;

void move(int n, char a, char c, char b)
{
    //从a柱子上，借助b的帮助，把n片移动到c上
    if (n == 0) return;

    //把n-1片，借助c移动到b上，临时放一下
    move(n - 1, a, b, c);
    
    step++;
    printf("第%d步，从%c号柱子，移动到%c号柱子\n", step, a, c);

    //再把n-1片，移动到c上
    move(n - 1, b, c, a);
}

int main()
{
    //freopen("hanoi3.in", "r", stdin);
    //freopen("hanoi3.out", "w", stdout);

    int n;
    cin >> n;

    move(n, 'a', 'c', 'b'); //借助b，挪动到c上

    return 0;
}
```

#### T122437 汉诺塔问题2
输出的不是从哪个柱子移动哪个柱子上了
输出把第几号盘子从哪个柱子移动到哪个柱子上
一本通有个隐藏题意是b是目标柱子
```cpp
//一本通原题上是要把a上的盘子，全部移动到b柱子上
#include <iostream>
#include <cstdio>
#include <fstream>

using namespace std;

int m;

void move(int n, char a, char b, char c)
{
    //从a移动n个盘子到c上, b杆作为过渡
    if (n == 0) return ;

    move(n - 1, a, c, b);  //把n-1个盘子，临时放在b上, c作为过渡

    printf("%c->%d->%c\n", a, n, c);

    move(n - 1, b, a, c);
}

int main()
{
    //freopen("hanoi02.in", "r", stdin);
    //freopen("hanoi02.out", "w", stdout);

    int m;
    char a, b, c;

    cin >> m >> a >> b >> c;

    move(m, a, c, b); //a杆上的移动到b杆上，c作为辅助

    return 0;
}
```


#### T122438 汉诺塔问题3
自己出的
更改盘子顺序，大盘子在上，小盘子在下
目标柱子是c柱子
```cpp
//http://www.4399.com/flash/293_1.htm
//为了匹配这个游戏，改造代码
//盘子的顺序反过来，大盘子在上，小盘子在下
//从a盘，移动到c盘子上

#include <iostream>
#include <cstdio>
#include <fstream>

using namespace std;

int m;
char a, b, c;

void move(int n, char a, char b, char c)
{
    //从a移动n个盘子到c上, b杆作为过渡
    if (n == 0) return ;

    move(n - 1, a, c, b);  //把n-1个盘子，临时放在b上, c作为过渡

    //printf("---%d, %d, %d\n", n, m, m - n + 1);
    printf("%c->%d->%c\n", a, m - n + 1, c);

    move(n - 1, b, a, c);
}

int main()
{
    //freopen("hanoi22.in", "r", stdin);
    //freopen("hanoi22.out", "w", stdout);
    
    cin >> m >> a >> b >> c;

    //cout << m << a << b << c << endl;

    move(m, a, b, c); //b作为辅助

    return 0;
}
```

#### P1255 数楼梯
三种做法
递归 40分，大数据需要高精度
```cpp
#include <iostream>

using namespace std;

int dfs(int n)
{
    if (n == 1) return 1;
    if (n == 2) return 2;

    return dfs(n - 1) + dfs(n - 2);
}

int main()
{
    int n;
    cin >> n;

    cout << dfs(n) << endl;

    return 0;
}
```

拓展高精度模板
```cpp
//Wrong Answer. wrong answer Too short on line 1.
//第六个测试点是0，没有讨论0的情况。还有就是这种报错的归类

#include <iostream>
#include <cstdio>
#include <vector>

using namespace std;

const int N = 5010;
vector<int> q[N];

vector<int> add(vector<int> &A, vector<int> &B)
{
    vector<int> C;

    for (int i = 0, t = 0; i < A.size() || i < B.size() || t; i++)
    {
        if (i < A.size()) t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
    
    return C;
}

int main()
{   
    int n; 
    cin >> n;

    if (n == 0) {cout << 0 << endl; return 0;}
    if (n == 1) {cout << 1 << endl; return 0;}
    if (n == 2) {cout << 2 << endl; return 0;}
    
    q[1].push_back(1);
    q[2].push_back(2);
    for (int i = 3; i <= n; i++)
        q[i]  = add(q[i - 1], q[i - 2]);
    
    vector<int> C = q[n];
    for (int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);
    puts("");

    
    return 0;
}
```

用二维数组模拟高精加法
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

const int N = 5010;

int g[N][N]; //每一行代表一层的步数值，倒序存储，高精加法
int len = 1;

void add(int k)
{
    for (int i = 1; i <= len; i++)
        g[k][i] = g[k - 1][i] + g[k - 2][i];

    for (int i = 1; i <= len; i++)
        if (g[k][i] >= 10)  //发生进位
        {
            g[k][i + 1] += g[k][i] / 10;
            g[k][i] %= 10;
        }
    if (g[k][len + 1]) len++;
}

int main()
{
    int n;
    cin >> n;

    g[1][1] = 1, g[2][1] = 2;
    for (int k = 3; k <= n; k++)
        add(k);
    
    for (int i = len; i >= 1; i--) printf("%d", g[n][i]);
    puts("");

    return 0;
}
```

#### T122198 分解因数
两种做法
dfs(a, 2),从2开始往上分解
dfs(a, a),从a开始往下试除

```cpp
#include <iostream>
#include <fstream>

using namespace std;

int dfs(int x, int u)
{
    if (x == 1) return 1;

    int sum = 0;
    for (int i = u; i <= x; i++)
        if (x % i == 0)
            sum += dfs(x / i, i);

    return sum;
}

int main()
{
    //freopen("yinshu2.in", "r", stdin);
    //freopen("yinshu2.out", "w", stdout);

    int n;
    cin >> n;

    while (n--)
    {
        int a;
        cin >> a;

        cout << dfs(a, 2) << endl; //从2开始分解因子
    }

    return 0;
}
```

```cpp
#include <iostream>
  
using namespace std;

int dfs(int a, int b)
{
    if (a == 1) return 1;
    if (b == 1) return 0;

    if (a % b == 0)
        return dfs(a / b, b) + dfs(a, b - 1);

    return dfs(a, b - 1);
}

int main()
{
    int n;
    cin >> n;

    while (n--)
    {
        int a;
        cin >> a;

        cout << dfs(a, a) << endl;
    }

    return 0;
}
```


#### P1028 数的计算
`dfs`
递归（25分）
记忆化搜索

`前缀和`  这个后面再讲
递推
递推优化
递推优化


递归25分
```cpp
#include <iostream>
#include <fstream>

using namespace std;

int dfs(int x)
{
    if (x == 1) return 1;

    int sum = 1;
    for (int i = 1; i <= x / 2; i++)
        sum += dfs(i);
   
    return sum;
}

int main()
{   
    int n; 
    cin >> n;
    
    cout << dfs(n) << endl;
    
    return 0;
}
```

记忆化搜索
```cpp
/*
记忆化搜索
*/

#include <iostream>
#include <cstring>


using namespace std;

const int N = 1010;

int h[N];

void dfs(int x)
{
    if (h[x] != -1) return ;

    h[x] = 1;
    for (int i = 1; i <= x / 2; i++)
    {
        dfs(i);
        h[x] += h[i];
    }

    return ;
}

int main()
{
    int n;
    cin >> n;

    memset(h, -1, sizeof h);

    dfs(n);

    cout << h[n] << endl;

    //for (int i = 1; i <= n; i++) cout << h[i] << ' ';
    //puts("");

    return 0;
}
```

#### T122199 判断元素是否存在
往远处搜索，判断这条数轴上，是否存在2y+1，3y+1。就能判断是否是集合中的元素

```cpp
#include <iostream>
#include <cstdio>
#include <fstream>

using namespace std;

int k, x;

bool dfs(int y)
{
    if (y > x) return false;
    if (y == x) return true;

    if (y < x) return dfs(2 * y + 1) || dfs(3 * y + 1);
}

int main()
{
    //freopen("yuansu2.in", "r", stdin);
    //freopen("yuansu2.out", "w", stdout);

    scanf("%d,%d", &k, &x);

    if (dfs(k)) cout << "YES" << endl;
    else cout << "NO" << endl;

    return 0;
}
```

#### T122385 放苹果
M个苹果放N个同样的盘子，允许有盘子为空，求多少种放法
分情况讨论，盘子比苹果多，苹果比盘子多(每个盘子都放+至少有一个盘子不放)
很像第二类斯特林数
```cpp
#include <iostream>
#include <fstream>

using namespace std;

int dfs(int m, int n)
{
    //0个苹果，1个盘子的时候，放法只有1个
    if (m == 0 || n == 1) return 1; 
    
    //盘子比苹果多，相当于m个苹果放m个盘子
    if (m < n) return dfs(m, m);
    //每一个盘子都放一个 + 至少有一个盘子不放
    if (m >= n) return dfs(m - n, n) + dfs(m, n - 1);
}

int main()
{
    //freopen("apple3.in", "r", stdin);
    //freopen("apple3.out", "w", stdout);

    int T;
    cin >> T;

    while (T--)
    {
        int m, n;
        cin >> m >> n;  //m个苹果，n个盘子

        cout << dfs(m, n) << endl;
    }
    
    return 0;
}
```
#### T122413 集合的划分
把集合划分成k个子集，子集之间没有交集，问多少种划分方法
子集{an}是k个子集中的一个
子集{an}不是k个自己中的一个，an必然与其他元素构成了一个子集，那么就可能和k个自己都可能有染
一本通的数据爆int，开longlong
```cpp
//n个元素，划分成k个子集
#include <iostream>
#include <cstdio>
#include <fstream>

using namespace std;

typedef long long LL;

LL dfs(int n, int k)
{
    if (n < k || k == 0) return 0;
    if (k == 1 || k == n) return 1;
    
    //{an}是k个子集里的一个 1...n-1,放进{1...k-1}, 少了{an}就是少了一个子集   dfs(n - 1, k - 1)
    //{an}不是k子集里的一个，那么an与其他元素组合一个集合 1...n-1，放进{1... k}，再把an插入这k个子集里的任意一个自己里去

    return dfs(n - 1, k - 1) + k * dfs(n - 1, k);
}

int main()
{
    //freopen("jihe2.in", "r", stdin);
    //freopen("jihe2.out", "w", stdout);

    int n, k;
    scanf("%d%d", &n, &k);

    printf("%lld\n", dfs(n, k));

    return 0;
}

```



#### 
T122565 逆波兰表达式
四种做法：
读入字符串的时候，就是一个分情况讨论，读入加减乘除就是四种递归情况
使用双指针，自己倒腾小数点
使用stringstream，转成double
使用sscanf，转成double
使用atof()

使用双指针

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

double res;
string s;

double to_string(string s)
{
    //双指针算法处理，把字符串转化成小数
    int mid = s.find('.');
    if (mid == -1)  //读入一个整数的时候
    {
        double a = 0.0;
        for (int i = 0; i < s.size(); i++) a = a * 10 + (s[i] - '0');

        return a;
    }

    int ed = s.size();
    double a = 0.0;
    for (int i = 0; i < mid; i++) a = a * 10 + (s[i] - '0');
    double b = 0.1;
    for (int i = mid + 1; i < ed; i++, b *= 0.1) a = a + (s[i] - '0') * b;

    return a;
}

double dfs()
{
    cin >> s;

    if (s[0] == '+') res = dfs() + dfs();
    else if (s[0] == '-') res = dfs() - dfs();
    else if (s[0] == '*') res = dfs() * dfs();
    else if (s[0] == '/') res = dfs() / dfs();
    else res = to_string(s);

    return res;
}

int main()
{
    printf("%f\n", dfs());

    return 0;
}
```


使用stringstream
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <sstream>

using namespace std;

double res;
char s[110];

double to_string(string s)
{
    //使用stringstream
    //sscanf(s, "%lf", &a);
    //cout << a << endl;

    stringstream tempIO;
    tempIO << s;

    double a;
    tempIO >> a;

    return a;
}

double dfs()
{
    scanf("%s", s);

    if (s[0] == '+') res = dfs() + dfs();
    else if (s[0] == '-') res = dfs() - dfs();
    else if (s[0] == '*') res = dfs() * dfs();
    else if (s[0] == '/') res = dfs() / dfs();
    else res = to_string(s);

    return res;
}

int main()
{
    printf("%f\n", dfs());

    return 0;
}
```

使用sscanf
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <sstream>

using namespace std;

double res;
char s[110];

double to_string(char s[])
{
    //使用sscanf()
    double a;
    sscanf(s, "%lf", &a);

    return a;
}

double dfs()
{
    scanf("%s", s);

    if (s[0] == '+') res = dfs() + dfs();
    else if (s[0] == '-') res = dfs() - dfs();
    else if (s[0] == '*') res = dfs() * dfs();
    else if (s[0] == '/') res = dfs() / dfs();
    else res = to_string(s);

    return res;
}

int main()
{
    printf("%f\n", dfs());

    return 0;
}
```

使用atof()
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <fstream>

using namespace std;

double res;
char s[110];

double dfs()
{
    scanf("%s", s);

    if (s[0] == '+') res = dfs() + dfs();
    else if (s[0] == '-') res = dfs() - dfs();
    else if (s[0] == '*') res = dfs() * dfs();
    else if (s[0] == '/') res = dfs() / dfs();
    else res = atof(s);

    return res;
}

int main()
{
    //freopen("ni2.in", "r", stdin);
    //freopen("ni2.out", "w", stdout);

    printf("%f\n", dfs());
    
    return 0;
}
```


#### 
T122589 扩号匹配问题
左括号不能匹配用$标记，右括号不能匹配用?标记
递归：左括号都先标记上$，然后遇到右括号就向前搜索是否匹配的左括号
栈：ss[]0，1没有配对的左括号，2没有配对的右括号。遇到左括号，就把ss[i]标记成1，把i的位置压栈
如果遇到右括号，就看栈是否为空。不为空，就有匹配的左括号。

用递归写
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <fstream>

using namespace std;

char s[110], st[110]; //原字符串，标记数组

int dfs(int u)
{
    if (u == -1) return -1;

    int t;
    if (st[u] == '$') return u;
    else t = dfs(u - 1); //这行如果不加return，会炸..想想盗梦空间，继续往下一层钻，下一层返回的值
                        //或者写成return dfs(u  -1)
    return t;
}

int main()
{
    //freopen("kuohao2.in", "r", stdin);
    //freopen("kuohao2.out", "w", stdout);

    while (scanf("%s", s) == 1)
    {
        printf("%s\n", s);

        int len = strlen(s);
        memset(st, ' ', sizeof st);

        for (int i = 0; i < len; i++)
        {   
            if (s[i] == '(') st[i] = '$';   //不管三七二十一，先标记左括号
            
            if (s[i] == ')')
            {   
                int t = dfs(i - 1); //向前找右括号的左括号
                
                if (t == -1) st[i] = '?'; //没找到匹配的左括号
                else st[t] = ' '; //找到匹配的左括号，配对成功，清除$标记
            }   
        } 

        printf("%s\n", st);
    }

    return 0;
}
```

用栈写
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

const int N = 110;

int stk[N], ss[N];
int tt;
string s;

int main()
{   
    while (cin >> s)
    {   
        tt = 0; 
        int len = s.size();
        
        memset(stk, 0, sizeof stk);
        memset(ss, 0, sizeof ss);
        
        for (int i = 0; i < len; i++)
        {   
            if (s[i] == '(')
            {   
                stk[++tt] = i;
                ss[i] = 1;  //1代表尚未匹配的左括号
            }
            
            if (s[i] == ')')
            {   
                ss[i] = 2; //2代表尚未匹配的右括号
                
                if (tt > 0)  //栈非空，就是前面还有左括号
                {   
                    ss[stk[tt]] = 0;  //栈里的左括号找到匹配
                    ss[i] = 0;        //这个右括号找到匹配
                    
                    tt--;
                }
            }
        }
        
        cout << s << endl;
        for (int i = 0; i < len; i++)
        {   
            if (ss[i] == 0) cout << ' ';
            if (ss[i] == 1) cout << '$';
            if (ss[i] == 2) cout << '?';
        }
        puts("");

    }

    return 0;
}
```
