### T133872 试除法判定质数
背一下试除法判断质数的模板

```cpp
#include <iostream>
#include <fstream>

using namespace std;

bool is_prime(int x)
{
	if (x < 2) return false;
	for (int i = 2; i <= x / i; i++)
		if (x % i == 0) return false;

	return true;
}

int main()
{
	int n;
	cin >> n;

	while (n--)
	{
		int a;
		cin >> a;

		if (is_prime(a)) cout << "Yes" << endl;
		else cout << "No" << endl;
	}

	return 0;
}
```

### T133874 分解质因数
对于一个数，从2开始枚举，i <= x / i，如果发现能整除，就除干净，用cnt记录指数

```cpp
#include <iostream>
#include <fstream>

using namespace std;

void divide(int x)
{
	for (int i = 2; i <= x / i; i++)
	{
		if (x % i == 0)
		{
			int cnt = 0;
			while (x % i == 0) x /= i, cnt++;
			cout << i << ' ' << cnt << endl;
		}
	}
	
	if (x > 1) cout << x << ' ' << 1 << endl;
}

int main()
{
	int n;
	cin >> n;

	while (n--)
	{
		int x;
		cin >> x;

		divide(x);
		cout << endl;
	}

	return 0;
}

```

### P3383 【模板】线性筛素数
1.用打表的方法，把1到1000之间的素数筛出来，并打印（朴素，埃式，线性）
2.然后将P3383的题目，用函数的方式，用三种筛法进行打表初始化，观察提交代码后的耗时情况(interesting)

### 朴素筛法
输出1到1000之间的质数
```cpp
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
	//对于任何一个数p，从2到p-1，没有把p删掉
	//p不是2到p-1所有数的倍数，也就是2到p-1没有p的约数，那么p就是质数

	//时间复杂度 n/2 + n/3 + n/4 + ... + n/n
	//n * (1/2 + 1/3 + 1/4 + ... + 1/n)  调和级数 nlnn

	for (int i = 2; i <= n; i++)
	{
		if (!st[i]) 
		{
			primes[cnt++] = i;
		}

		for (int j = i + i; j <= n; j += i) st[j] = true; //把自己的倍数，筛掉 这里的i可能是质数也可能是合数
		
		// 2的所有倍数，3的所有倍数，4的所有倍数。 12这个数，就被筛了很多次
	}
}

int main()
{
	int n;
	cin >> n;

	get_primes(n);

	cout << cnt << endl;

	for (int i = 0; i < cnt; i++) cout << primes[i] << ' ' << endl;

	return 0;
}

```

### 埃式筛法（埃拉托斯特尼筛法）
输出1到1000之间的质数
```cpp
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
	//1-n中有 n/lnn 个质数
	//朴素筛法的时间复杂度是nlnn, 把n换成n/lnn，化简得O(n)  这是一个估算 精确值是O(nloglogn)

	for (int i = 2; i <= n; i++)
	{
		if (!st[i]) 
		{
			primes[cnt++] = i;
			for (int j = i + i; j <= n; j += i) st[j] = true; //把自己的倍数，筛掉,注意这里就只筛掉质数的倍数即可
		}
	}

	//这里 1 2 3 4 5 6 7 8， 6会被2筛一次，被3筛一次。还可以进行优化
}

int main()
{
	int n;
	cin >> n;

	get_primes(n);

	cout << cnt << endl;

	for (int i = 0; i < cnt; i++) cout << primes[i] << ' ' << endl;

	return 0;
}

```

#### 线性筛法
```cpp
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
	//核心：n只会被他的最小质因子筛掉
	for (int i = 2; i <= n; i++)
	{
		if (!st[i]) 
		{
			primes[cnt++] = i;
		}

		for (int j = 0; primes[j] <= n / i; j++)
		{
			st[primes[j] * i] = true; //给i乘上一个质因子
			if (i % primes[j] == 0) break; //如果i是pj的倍数，i*pj已经被pj筛过的了，所有就break出来
		}

		//i % primes[j] == 0, pj一定是pj * i 的最小质因子
		//i % primes[j] != 0, pj也一定是pj的最小质因子
	}
}

int main()
{
	int n;
	cin >> n;

	get_primes(n);

	cout << cnt << endl;

	for (int i = 0; i < cnt; i++) cout << primes[i] << ' ' << endl;

	return 0;
}

```

### P3383 【模板】线性筛素数
用三种筛法，做这道题目，观察耗时
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

const int N = 1e8 + 10;

int primes[N], cnt;
bool st[N];

void pusu_primes(int n)
{
	for (int i = 2; i <= n; i++)
	{
		if (!st[i]) 
		{
			primes[cnt++] = i;
		}

		for (int j = i + i; j <= n; j += i) st[j] = true; //把自己的倍数，筛掉 这里的i可能是质数也可能是合数
		
		// 2的所有倍数，3的所有倍数，4的所有倍数。 12这个数，就被筛了很多次
	}
}

void aishi_primes(int n)
{
	for (int i = 2; i <= n; i++)
	{
		if (!st[i]) 
		{
			primes[cnt++] = i;
			for (int j = i + i; j <= n; j += i) st[j] = true; //把自己的倍数，筛掉,注意这里就只筛掉质数的倍数即可
		}
	}
}

void xianxing_primes(int n)
{
	//核心：n只会被他的最小质因子筛掉
	for (int i = 2; i <= n; i++)
	{
		if (!st[i]) 
		{
			primes[cnt++] = i;
		}

		for (int j = 0; primes[j] <= n / i; j++)
		{
			st[primes[j] * i] = true; //给i乘上一个质因子
			if (i % primes[j] == 0) break; //如果i是pj的倍数，i*pj已经被pj筛过的了，所有就break出来
		}

		//i % primes[j] == 0, pj一定是pj * i 的最小质因子
		//i % primes[j] != 0, pj也一定是pj的最小质因子
	}
}

int main()
{
	int n, m;
	cin >> n >> m;

	pusu_primes(n);
//	aishi_primes(n);
//	xianxing_primes(n);

	while (m--)
	{
		int k;
		scanf("%d", &k);

		printf("%d\n", primes[k - 1]);
	}

	return 0;
}

```

```cpp
#include <iostream>
#include <cstdio>
#include <fstream>

using namespace std;

const int N = 1e8 + 10;

int primes[N], cnt;
bool st[N];

int main()
{
    int n, m;
    cin >> n >> m;
    
    for (int i = 2; i <= n; i++)
    {
        if (!st[i]) primes[cnt++] = i;
        for (int j = 0; primes[j] <= n / i; j++)
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }

    while (m--)
    {   
        int a;
        scanf("%d", &a);
        
        printf("%d\n", primes[a - 1]);
    }

    return 0;
}

```

### P1029 最大公约数和最小公倍数问题
```cpp
#include <iostream>

using namespace std;

int cnt;

int gcd(int a, int b)
{
	//if (a < b) return gcd(b, a);
	return b ? gcd(b, a % b): a; //这个地方的前后大小，是没关系的
}

int main()
{
	int x, y;
	cin >> x >> y;

	int gcdlcm = x * y;
	for (int i = x; i <= gcdlcm; i += x)
	{
		if (gcdlcm % i == 0 && gcd(i, gcdlcm / i) == x) 
		{
			//cout << i << ' ' << gcdlcm / i << endl;

			cnt++;
		}
	}

	cout << cnt << endl;

	return 0;
}

```

### P2043 质因子分解
```cpp
#include <iostream>

using namespace std;

const int N = 10010;

int cnt[N];

void divide(int x)
{
	for (int i = 2; i <= x / i; i++)
	{
		if (x % i == 0)
		{
			int s = 0;
			while (x % i == 0) x /= i, s++;

			cnt[i] += s;
		}
	}

	if (x > 1) cnt[x] += 1;
}

int main()
{
	int n;
	cin >> n;

	for (int i = 2; i <= n; i++)
		divide(i);
	
	for (int i = 2; i <= n; i++)
		if (cnt[i])
			cout << i << ' ' << cnt[i] << endl;

	return 0;
}

```

### P1075 质因数分解
这是一道math的脑经急转弯的题

```cpp
#include <algorithm>
#include <cmath>
#include <bits/stdc++.h>

using namespace std;

int main()
{
	int n;
	cin >> n;

	int size = sqrt(n);
	for (int i = 2; i < size + 1; i++)
		if (n % i == 0)
		{
			cout << n / i << endl;
			return 0;
		}

	return 0;
}
```