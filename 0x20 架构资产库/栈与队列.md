#### T113758 模拟栈【模板】
一维数组模拟栈

```cpp
#include <iostream>
#include <fstream>

using namespace std;

const int N = 1e6 + 10;

typedef long long LL;

int M;
LL stk[N];
int tt = 0;

int main()
{
    //freopen("stack.in", "r", stdin);
    cin >> M;

    string op;
    LL x;
    while (M--){
        cin >> op;

        if (op == "push")
        {
            cin >> x;
            stk[++tt] = x;
        }
        else if (op == "pop")
        {
            tt--;
        }
        else if (op == "empty")
        {
            if (!tt) cout << "YES";
            else cout << "NO";
            puts(" ");
        }
        else if (op == "query")
        {
            cout << stk[tt] << endl;
        }
    }

    return 0;
}
```

#### P1739 表达式括号匹配

```cpp
#include <iostream>

using namespace std;

const int N = 25;

char stk[N];
int tt = 0;

int main()
{
    string str;
    cin >> str;

    for (int i = 0; str[i] != '@'; i++)
    {
        if (str[i] == '(') 
            stk[++tt] = '(';
        
        if (str[i] == ')')
        {
            if (!tt) 
            {
                cout << "NO" << endl;
                return 0;
            }

            if (stk[tt] == '(') --tt;
        }
    }

    if (tt == 0) cout << "YES" << endl;
    else cout << "NO" << endl;

    return 0;
}
```
#### T122589 扩号匹配问题【扩展】
学习递归的时候，学了这道题目，现在用栈来实现。
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

const int N = 110;

int stk[N], ss[N];
int tt;
string s;

int main()
{   
    while (cin >> s)
    {   
        tt = 0; 
        int len = s.size();
        
        memset(stk, 0, sizeof stk);
        memset(ss, 0, sizeof ss);
        
        for (int i = 0; i < len; i++)
        {   
            if (s[i] == '(')
            {   
                stk[++tt] = i;
                ss[i] = 1;  //1代表尚未匹配的左括号
            }
            
            if (s[i] == ')')
            {   
                ss[i] = 2; //2代表尚未匹配的右括号
                
                if (tt > 0)  //栈非空，就是前面还有左括号
                {   
                    ss[stk[tt]] = 0;  //栈里的左括号找到匹配
                    ss[i] = 0;        //这个右括号找到匹配
                    
                    tt--;
                }
            }
        }
        
        cout << s << endl;
        for (int i = 0; i < len; i++)
        {   
            if (ss[i] == 0) cout << ' ';
            if (ss[i] == 1) cout << '$';
            if (ss[i] == 2) cout << '?';
        }
        puts("");

    }

    return 0;
}
```

#### T113769 模拟队列【模板】
一维数组模拟队列

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

const int N = 100010;

int q[N];

int main()
{
	//freopen("duilie.in","r",stdin);
	int m, tt = -1, hh = 0;
	cin >> m;
	int shu;
	string a;
	
	for (int i = 0; i < m; i++)
	{
		cin >> a;
		
		if (a == "push")
		{
			cin >> shu;
			q[++tt] = shu;
		} 
		
		else if (a == "pop")
		{
			hh++;
		}
		
		else if (a == "empty")
		{
			if (hh <= tt)
			{
				cout << "NO";
			}
			else 
			{
				cout << "YES";
			}
			puts("");
		}
		else if (a == "query")
		{
			cout << q[hh] << endl;
		}
	}
	return 0;
} 
```

#### P1996 约瑟夫问题
```cpp
#include <iostream>
#include <queue>

using namespace std;

queue<int> q;
int n, m;

int main()
{
	cin >> n >> m;

	for (int i = 1; i <= n; i++) q.push(i);

	while (q.size())
	{
		for (int i = 1; i < m; i++)
		{
			int t = q.front();
			q.pop();

			q.push(t);
		}

		cout << q.front() << ' ';
		q.pop();
	}
	cout << endl;

	return 0;
}
```