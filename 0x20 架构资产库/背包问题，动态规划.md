### 01背包
### P1048 采药

第一种写法
```cpp
#include <bits/stdc++.h>

using namespace std;

int v[1010], w[110];
int f[110][10010];
int n, m;

int main()
{
	scanf("%d%d", &m, &n);

	for (int i = 1; i <= n; i++) scanf("%d%d", &v[i], &w[i]);
	
	f[0][0] = 0;
	for (int i= 1; i <= n; i++)
		for (int j = 0; j <= m; j++)
		{
			f[i][j] = f[i - 1][j];
			if (j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
		}
	
	printf("%d\n", f[n][m]);
	
	return 0;
}
```

第二种写法，滚动数组优化
```cpp
#include <bits/stdc++.h>

using namespace std;

int v[1010], w[110];
int f[2][10010];
int n, m;

int main()
{
	scanf("%d%d", &m, &n);

	for (int i = 1; i <= n; i++) scanf("%d%d", &v[i], &w[i]);
	
	f[0][0] = 0;
	for (int i= 1; i <= n; i++)
		for (int j = 0; j <= m; j++)
		{
			f[i & 1][j] = f[(i - 1) & 1][j];
			if (j >= v[i]) f[i & 1][j] = max(f[i & 1][j], f[(i - 1) & 1][j - v[i]] + w[i]);
		}
	
	printf("%d\n", f[n & 1][m]);
	
	return 0;
}
```

第三种写法，一维数组优化
```cpp
#include <bits/stdc++.h>

using namespace std;

int v[1010], w[110];
int f[10010];
int n, m;

int main()
{
	scanf("%d%d", &m, &n);

	for (int i = 1; i <= n; i++) scanf("%d%d", &v[i], &w[i]);
	
	f[0] = 0;
	for (int i= 1; i <= n; i++)
		for (int j = m; j >= v[i]; j--)
			f[j] = max(f[j], f[j - v[i]] + w[i]);
	
	printf("%d\n", f[m]);
	
	return 0;
}
```

### P2871 [USACO07DEC]Charm Bracelet S
```cpp
#include <bits/stdc++.h>

using namespace std;

int v[3402 + 10], w[3402 + 10];
int f[400 * 4000 + 10];
int n, m;

int main()
{
	scanf("%d%d", &n, &m);

	for (int i = 1; i <= n; i++) scanf("%d%d", &v[i], &w[i]);

	for (int i = 1; i <= n; i++)
		for (int j = m; j >= v[i]; j--)
			f[j] = max(f[j], f[j - v[i]] + w[i]);

	printf("%d\n", f[m]);

	return 0;
}
```

### P1060 开心的金明
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e8 + 10;

int v[30010], w[30];
int f[N];
int n, m;

int main()
{
	scanf("%d%d", &m, &n);

	for (int i = 1; i <= n; i++) scanf("%d%d", &v[i], &w[i]);

	f[0] = 0;
	for (int i = 1; i <= n; i++)
		for (int j = m; j >= v[i]; j--)
			f[j] = max(f[j], f[j - v[i]] + v[i] * w[i]);

	printf("%d\n", f[m]);
	
	return 0;
}

```

### P1049 装箱问题
```cpp
//求剩余体积最小，问题转化为：物品能拼成的体积最大
//但这道题只有体积的，没有价值w[i]，f[i]表示的是i体积下(能放的物品体积之和)

#include <bits/stdc++.h>

using namespace std;

int v[20010];
int f[20010];
int n, m;

int main()
{
	scanf("%d%d", &m, &n);

	for (int i= 1; i <= n; i++)	scanf("%d", &v[i]);

	f[0] = 0;
	for (int i = 1; i <= n; i++)
		for (int j = m; j >= v[i]; j--)
			f[j] = max(f[j], f[j - v[i]] + v[i]);

	printf("%d\n", m - f[m]);

	return 0;
}

```
