### P1308 统计单词数

第一种做法，用数组模拟匹配方法，从头到尾，匹配一遍
```cpp
#include <iostream>
#include <fstream>
#include <cstring>
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;

string str;
string q;

int ans;
int pos;
bool flag;

int main()
{
	//freopen("tongji.in", "r", stdin);
	getline(cin, str);
	getline(cin, q);

	int lenstr, lenq;
	for (int i = 0, lenstr = 0; str[i] != '\0'; i++, lenstr++)
		if (str[i] >= 'A' && str[i] <= 'Z') str[i] += 32;

	for (int i = 0, lenq = 0; q[i] != '\0'; i++, lenq++)
		if (q[i] >= 'A' && q[i] <= 'Z') q[i] += 32;

	lenstr = str.size(), lenq = q.size();

	int i, j, k;
	for (i = 0, k = 0; i < lenq; )
	{
		j = i;
	
		while (q[j] == str[k] && q[j] && str[k])
		{
//			printf("!--%c %c\n", q[j], str[k]);
			j++, k++;
		}

		if (str[k] == '\0' && q[j] == ' ' || str[k] == '\0' && q[j] == '\0')
		{
			ans++;
//			printf("+++%d\n", i);
			if (!flag)
			{
				pos = i;
				flag = true;
			}
		}
		else
			while (q[j] != ' ' && q[j] != '\0') j++;
		
		i = j + 1;
		k = 0;
	}

	if (!ans) cout << "-1" << endl;
	else cout << ans << ' ' << pos << endl;

	return 0;
}
```

第二种做法

利用string的find函数
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <fstream>

using namespace std;

string a, b;
vector<int> pos;

void to_lower(string &s)
{
	for (int i = 0, len = s.size(); i <len; i++)
		if (s[i] >= 'A' && s[i] <= 'Z') s[i] += 32;
}

int main()
{
	//freopen("P1308_6.in", "r", stdin);

	getline(cin, a);
	getline(cin, b);

	to_lower(a), to_lower(b);

	int ans = 0;
	while (b.find(a) != -1)
	{
		int p = b.find(a);

		char before = b[p - 1];
		char after = b[p + a.size()];

		if ((p == 0 && (after == ' ' || after == '\n')) || (p != 0 && before == ' ' && (after == ' ' || after == '\n')))  //找到的是一个完整的a单词
		{
			pos.push_back(p);
			ans++;
		}
		
		b[p] = '0'; //改成一个不相关的字符
	}

	if (!ans) cout << -1 << endl;
	else cout << ans << ' ' << pos[0] << endl;

	return 0;
}
```

