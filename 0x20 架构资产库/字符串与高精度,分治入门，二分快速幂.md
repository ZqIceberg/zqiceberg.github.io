### P1308 统计单词数

第一种做法，用数组模拟匹配方法，从头到尾，匹配一遍

```cpp
#include <iostream>
#include <fstream>
#include <cstring>
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;

string str;
string q;

int ans;
int pos;
bool flag;

int main()
{
	//freopen("tongji.in", "r", stdin);
	getline(cin, str);
	getline(cin, q);

	int lenstr, lenq;
	for (int i = 0, lenstr = 0; str[i] != '\0'; i++, lenstr++)
		if (str[i] >= 'A' && str[i] <= 'Z') str[i] += 32;

	for (int i = 0, lenq = 0; q[i] != '\0'; i++, lenq++)
		if (q[i] >= 'A' && q[i] <= 'Z') q[i] += 32;

	lenstr = str.size(), lenq = q.size();

	int i, j, k;
	for (i = 0, k = 0; i < lenq; )
	{
		j = i;
	
		while (q[j] == str[k] && q[j] && str[k])
		{
//			printf("!--%c %c\n", q[j], str[k]);
			j++, k++;
		}

		if (str[k] == '\0' && q[j] == ' ' || str[k] == '\0' && q[j] == '\0')
		{
			ans++;
//			printf("+++%d\n", i);
			if (!flag)
			{
				pos = i;
				flag = true;
			}
		}
		else
			while (q[j] != ' ' && q[j] != '\0') j++;
		
		i = j + 1;
		k = 0;
	}

	if (!ans) cout << "-1" << endl;
	else cout << ans << ' ' << pos << endl;

	return 0;
}
```

第二种做法

利用string的find函数
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <fstream>

using namespace std;

string a, b;
vector<int> pos;

void to_lower(string &s)
{
	for (int i = 0, len = s.size(); i <len; i++)
		if (s[i] >= 'A' && s[i] <= 'Z') s[i] += 32;
}

int main()
{
	//freopen("P1308_6.in", "r", stdin);

	getline(cin, a);
	getline(cin, b);

	to_lower(a), to_lower(b);

	int ans = 0;
	while (b.find(a) != -1)
	{
		int p = b.find(a);

		char before = b[p - 1];
		char after = b[p + a.size()];

		if ((p == 0 && (after == ' ' || after == '\n')) || (p != 0 && before == ' ' && (after == ' ' || after == '\n')))  //找到的是一个完整的a单词
		{
			pos.push_back(p);
			ans++;
		}
		
		b[p] = '0'; //改成一个不相关的字符
	}

	if (!ans) cout << -1 << endl;
	else cout << ans << ' ' << pos[0] << endl;

	return 0;
}
```

### P1015 回文数

用数组模拟加法
```cpp
/*
1.判断回文
2.N进制加法，数组模拟加法
3.30步以内不可能得到结果，输出impossible，常用写法
*/

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

int N;  //N进制
string M; //数字用字符串读入
int step;

string sixteen = "0123456789ABCDEF";
int A[110], B[110], C[110]; //用来模拟加法运算

bool is_huiwen(string s)
{
	string t = s;
	reverse(t.begin(), t.end());

	if (t == s) return true;
	else return false;
}

string add(string a, string b, int n)
{
	reverse(b.begin(), b.end());

	//倒序存进来
	for (int i = 1, len = a.size(); i <= len; i++)
	{
		if ('0' <= a[len - i] && a[len - i] <= '9')
			A[i] = a[len - i] - '0';
		else
			A[i] = a[len - i] - 'A' + 10;

		if ('0' <= b[len - i] && b[len - i] <= '9')
			B[i] = b[len - i] - '0';
		else
			B[i] = b[len - i] - 'A' + 10;
	}
	
	int t = 0;
	int idx = 1;
	for (int i = 1, len = a.size(); i <= len; i++)
	{
		t += A[i] + B[i];

		C[idx++] = t % n;
		t /= n;
	}
	if (t) C[idx] = t;  //最高位发生进位

	while (C[idx] == 0) idx--;  //去前导零

	string ans;
	for (int i = idx; i >= 1; i--) 
		ans += sixteen[C[i]];

	return ans;
}

int main()
{
	cin >> N >> M;

	while (step <= 30)
	{
		if (is_huiwen(M))
		{
			cout << "STEP=" << step << endl;
			return 0;
		}
		else
		{
			step++;
			M = add(M, M, N);
		}
	}

	cout << "Impossible!" << endl;

	return 0;
}

```

用vector模拟加法，注意vector清除缓存的问题，先不清除，然后debug过程，分析，是一个很好提升代码能力的过程
```cpp
/*
1.判断回文
2.N进制加法，数组模拟加法
3.30步以内不可能得到结果，输出impossible，常用写法
*/

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

int N;  //N进制
string M; //数字用字符串读入
int step;

string sixteen = "0123456789ABCDEF";
int A[110], B[110], C[110]; //用来模拟加法运算

bool is_huiwen(string s)
{
	string t = s;
	reverse(t.begin(), t.end());

	if (t == s) return true;
	else return false;
}

string add(string a, string b, int n)
{
	reverse(b.begin(), b.end());

	//倒序存进来
	for (int i = 1, len = a.size(); i <= len; i++)
	{
		if ('0' <= a[len - i] && a[len - i] <= '9')
			A[i] = a[len - i] - '0';
		else
			A[i] = a[len - i] - 'A' + 10;

		if ('0' <= b[len - i] && b[len - i] <= '9')
			B[i] = b[len - i] - '0';
		else
			B[i] = b[len - i] - 'A' + 10;
	}
	
	int t = 0;
	int idx = 1;
	for (int i = 1, len = a.size(); i <= len; i++)
	{
		t += A[i] + B[i];

		C[idx++] = t % n;
		t /= n;
	}
	if (t) C[idx] = t;  //最高位发生进位

	while (C[idx] == 0) idx--;  //去前导零

	string ans;
	for (int i = idx; i >= 1; i--) 
		ans += sixteen[C[i]];

	return ans;
}

int main()
{
	cin >> N >> M;

	while (step <= 30)
	{
		if (is_huiwen(M))
		{
			cout << "STEP=" << step << endl;
			return 0;
		}
		else
		{
			step++;
			M = add(M, M, N);
		}
	}

	cout << "Impossible!" << endl;

	return 0;
}

```

### P1087 FBI树
学习str.substr(0, str.size() / 2)  取子串的方法

```cpp
#include <cstring>
#include <iostream>

using namespace std;

void dfs(string str)
{
	//和归并排序一样，先拆分下去，向上返回的时候再处理输出
	if (str.size() > 1)
	{
		dfs(str.substr(0, str.size() / 2));
		dfs(str.substr(str.size() / 2));
	} 
	
	//返回的时候，处理子串的类型，并输出类型
	//第一层，一个叶子节点；第二层，两个叶子一个父亲节点
	int one = 0, zero = 0;
	for (int i = 0; i < str.size(); i++)
		if (str[i] == '0') zero++;
		else one++;
	
	if (one && zero) cout << 'F';
	else if (one) cout << 'I';
	else cout << 'B';
}

int main()
{
	int n;
	cin >> n;
	
	string str;
	cin >> str;
	
	dfs(str);
	cout << endl;

	return 0;
}

```

### P1601 A+B Problem（高精）
vector模板题

```cpp
#include <iostream>
#include <vector>

using namespace std;

vector<int> A, B;
string a, b;

vector<int> add(vector<int> &A, vector<int> &B)
{
	vector<int> C;

	int t = 0;
	for (int i = 0; i < A.size() || i < B.size(); i++)
	{
		if (i < A.size()) t += A[i];
		if (i < B.size()) t += B[i];
		C.push_back(t % 10);
		t /= 10;
	}
	if (t) C.push_back(1);

	while (C.size() > 1 && C.back() == 0) C.pop_back();

	return C;
}

int main()
{
	cin >> a >> b;

	for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
	for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');

	vector<int> C;
	C = add(A, B);

	for (int i = C.size() - 1; i >= 0; i--) cout << C[i];
	cout << endl;

	return 0;
}

```

### P2142 高精度减法
vector模板题
```cpp
#include <iostream>
#include <cstdio>
#include <vector>

using namespace std;

vector<int> A, B;
string a, b;

bool cmp(vector<int> &A, vector<int> &B)
{
	if (A.size() > B.size()) return true;
	if (A.size() < B.size()) return false;

	for (int i = A.size() - 1; i >= 0; i--)
		if (A[i] < B[i]) return false;

	return true;
}

vector<int> sub(vector<int> &A, vector<int> &B)
{
	vector<int> C;
	int t = 0;
	for (int i = 0; i < A.size(); i++)
	{
		A[i] -= t;  //处理一下借位
		if (i < B.size()) A[i] -= B[i];
		C.push_back((A[i] + 10) % 10);
	
		if (A[i] < 0) t = 1;  //A[i] < 0就要借一位
		else t = 0;
	}

	while (C.size() > 1 && C.back() == 0) C.pop_back();

	return C;
}

int main()
{
	cin >> a >> b;
	
	for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
	for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');

	vector<int> C;
	if (cmp(A, B))
	{
		C = sub(A, B);
		for (int i = C.size() - 1; i >= 0; i--) cout << C[i];
		cout << endl;
	}
	else
	{
		cout << '-';
		C = sub(B, A);
		for (int i = C.size() - 1; i >= 0; i--) cout << C[i];
		cout << endl;
	}

	return 0;
}
```

### P1226 【模板】快速幂||取余运算
b的p次幂
每一个正整数可以唯一表示为若干指数不重复的2的次幂的和
p = Ck-1 * 2^(k-1) + ck-2 * 2^(k - 2) + ... + C0 * 2^0
b^p = a^(Ck-1 * 2^(k-1)) * a^(ck-2 * 2^(k - 2)) * ... 

Ci * 2^i, 当Ci不为0的时候，把该乘积累计到答案中
a^(2^i) 是可以通过递推求出来的

```cpp
#include <cstdio>
#include <iostream>

using namespace std;

typedef long long LL;

int qmi(int b, int p, int k)
{
    if (p == 0) return 0;

    int res = 1;
    while (p)
    {
    	//右移和与运算，遍历了b的二进制表示下的每一位
    	//在循环到第i次的时候，变量b中存储的b^(2^i)，若b该位为1，则此时的变量b累计到答案中

        if (p & 1) res = (LL)res * b % k;
        p >>= 1;
        b = (LL)b * b % k;
    }

    return res;
}

int main()
{
    int b, p, k;
    cin >> b >> p >> k;

    printf("%d^%d mod %d=%d\n", b, p, k, qmi(b, p, k));

    return 0;
}
```

### 二分查找
整数集合上的二分
实数域上的二分

### P2249 【深基13.例1】查找
使用二分模板来写

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

const int N = 1e6 + 10;

int a[N];
int n, m;

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	
	while (m--)
	{
		int x;
		scanf("%d", &x);

		int l = 1, r = n;
		while (l < r)
		{
			int mid = (l + r) >> 1;
			if (a[mid] >= x) r = mid;
			else l = mid + 1;
		}

		if (a[l] != x) cout << -1 << ' ';
		else cout << l << ' ';
	}
	puts("");
	
	return 0;
}
```

使用STL来写
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

const int N = 1e6 + 10;

int a[N];
int n, m;

int main()
{
	cin >> n >> m;
	//a是有序的
	for (int i = 0; i < n; i++) scanf("%d", &a[i]);

	while (m--)
	{
		int x;
		scanf("%d", &x);

		int pos = lower_bound(a, a + n, x) - a;
		if (a[pos] != x) printf("-1 ");
		else printf("%d ", pos + 1);
	}
	puts("");

	return 0;
}
```

### 二分答案转化为判定
### P1824 进击的奶牛

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int a[N];
int n, m;

int check(LL x)
{
	int sum = 1;
	int last = 0;
	for (int i = 1; i < n; i++) //从第2个牛舍开始遍历
	{
		if (a[i] - a[last] >= x) 
		{
			sum++;
			last = i;
		}
	}

	return sum;
}

int main()
{
	scanf("%d%d", &n, &m);

	for (int i = 0; i < n; i++) scanf("%d", &a[i]);

	sort(a, a + n);

	int l = 0, r = a[n - 1] - a[0];
	while (l < r)
	{
		int mid = (l + r + 1) >> 1;
		if (check(mid) >= m) l = mid;
		else r = mid - 1;
	}

	printf("%d\n", l);

	return 0;
}
```

### 实数域上的二分

### P1163 银行贷款

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int dk, fq, month;

bool check(double x)
{
	double t = 1.0 * dk;

	for (int i = 1; i <= month; i++)
		t = t * (1 + x / 100.0) - fq;

	return t > 0;  //利率设置高的话，现有的fq付款，就还不完贷款
}

int main()
{
	cin >> dk >> fq >> month;
	
	double l = 0.0, r = 1000.0;  //先尝试100.0，再尝试1000.0
	while (r - l > 1e-6)
	{
		double mid = (l + r) / 2;
		if (check(mid)) r = mid;
		else l = mid;
	}

	printf("%.1lf\n", l);

	return 0;
}

```

